"""
server.py.tmpl - Python gRPC server entry point

Author: {{AUTHOR}}
Project: {{PROJECT_NAME}}
"""

import asyncio
import logging
import os
import signal
from concurrent import futures

import grpc
from grpc_health.v1 import health, health_pb2_grpc
from grpc_reflection.v1alpha import reflection

from services.user_service import UserService
from services.auth_service import AuthService

# Generated protobuf imports (adjust paths based on your generation)
# from gen.user.v1 import user_pb2_grpc
# from gen.auth.v1 import auth_pb2_grpc


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class Config:
    """Server configuration from environment variables."""

    def __init__(self):
        self.port = os.getenv("GRPC_PORT", "50051")
        self.database_url = os.getenv("DATABASE_URL", "")
        self.jwt_secret = os.getenv("JWT_SECRET", "")
        self.max_workers = int(os.getenv("GRPC_MAX_WORKERS", "10"))
        self.enable_reflection = os.getenv("ENABLE_REFLECTION", "true").lower() == "true"


async def serve():
    """Start gRPC server with graceful shutdown."""
    config = Config()

    # Create server with thread pool
    server = grpc.aio.server(
        futures.ThreadPoolExecutor(max_workers=config.max_workers),
        interceptors=[
            LoggingInterceptor(),
            AuthInterceptor(config.jwt_secret),
        ]
    )

    # Initialize and register services
    user_service = UserService(config.database_url)
    auth_service = AuthService(config.database_url, config.jwt_secret)

    # TODO: Uncomment when protobuf files are generated
    # user_pb2_grpc.add_UserServiceServicer_to_server(user_service, server)
    # auth_pb2_grpc.add_AuthServiceServicer_to_server(auth_service, server)

    # Register health check
    health_servicer = health.HealthServicer()
    health_pb2_grpc.add_HealthServicer_to_server(health_servicer, server)
    health_servicer.set("", health_pb2.HealthCheckResponse.SERVING)

    # Enable reflection for development
    if config.enable_reflection:
        SERVICE_NAMES = (
            # TODO: Add service names
            # user_pb2.DESCRIPTOR.services_by_name['UserService'].full_name,
            # auth_pb2.DESCRIPTOR.services_by_name['AuthService'].full_name,
            reflection.SERVICE_NAME,
        )
        reflection.enable_server_reflection(SERVICE_NAMES, server)

    # Start server
    server.add_insecure_port(f"[::]:{config.port}")
    await server.start()
    logger.info(f"gRPC server listening on port {config.port}")

    # Graceful shutdown
    async def shutdown(sig):
        logger.info(f"Received signal {sig.name}, shutting down...")
        await server.stop(grace=5)

    loop = asyncio.get_event_loop()
    for sig in (signal.SIGTERM, signal.SIGINT):
        loop.add_signal_handler(sig, lambda s=sig: asyncio.create_task(shutdown(s)))

    await server.wait_for_termination()


class LoggingInterceptor(grpc.aio.ServerInterceptor):
    """Logs all RPC calls."""

    async def intercept_service(self, continuation, handler_call_details):
        logger.info(f"RPC called: {handler_call_details.method}")
        return await continuation(handler_call_details)


class AuthInterceptor(grpc.aio.ServerInterceptor):
    """Validates JWT tokens for protected endpoints."""

    def __init__(self, jwt_secret: str):
        self.jwt_secret = jwt_secret
        self.public_endpoints = {
            "/auth.v1.AuthService/Login",
            "/auth.v1.AuthService/RefreshToken",
            "/grpc.health.v1.Health/Check",
        }

    async def intercept_service(self, continuation, handler_call_details):
        # Skip auth for public endpoints
        if handler_call_details.method in self.public_endpoints:
            return await continuation(handler_call_details)

        # TODO: Validate JWT token from metadata
        # metadata = dict(handler_call_details.invocation_metadata)
        # token = metadata.get("authorization", "").replace("Bearer ", "")

        return await continuation(handler_call_details)


if __name__ == "__main__":
    asyncio.run(serve())
