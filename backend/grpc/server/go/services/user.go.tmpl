/**
 * user.go.tmpl - User service implementation
 *
 * Author: {{AUTHOR}}
 * Project: {{PROJECT_NAME}}
 */

package services

import (
	"context"
	"fmt"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	commonv1 "github.com/{{PROJECT_NAME}}/gen/common/v1"
	userv1 "github.com/{{PROJECT_NAME}}/gen/user/v1"
)

type UserService struct {
	userv1.UnimplementedUserServiceServer
	db string // TODO: Replace with actual database connection
}

func NewUserService(databaseURL string) *UserService {
	return &UserService{
		db: databaseURL,
	}
}

func (s *UserService) GetUser(ctx context.Context, req *userv1.GetUserRequest) (*userv1.GetUserResponse, error) {
	if req.Id == "" {
		return nil, status.Error(codes.InvalidArgument, "user id is required")
	}

	// TODO: Fetch from database
	user := &userv1.User{
		Id:        req.Id,
		Email:     "user@example.com",
		Username:  "exampleuser",
		FullName:  "Example User",
		AvatarUrl: "",
		IsActive:  true,
		Roles:     []string{"user"},
		CreatedAt: timestamppb.Now(),
		UpdatedAt: timestamppb.Now(),
	}

	return &userv1.GetUserResponse{
		User: user,
	}, nil
}

func (s *UserService) ListUsers(ctx context.Context, req *userv1.ListUsersRequest) (*userv1.ListUsersResponse, error) {
	// Set default pagination
	page := int32(1)
	perPage := int32(20)
	if req.Pagination != nil {
		if req.Pagination.Page > 0 {
			page = req.Pagination.Page
		}
		if req.Pagination.PerPage > 0 {
			perPage = req.Pagination.PerPage
		}
	}

	// TODO: Fetch from database with pagination and filters
	users := []*userv1.User{
		{
			Id:        "1",
			Email:     "user1@example.com",
			Username:  "user1",
			FullName:  "User One",
			IsActive:  true,
			Roles:     []string{"user"},
			CreatedAt: timestamppb.Now(),
			UpdatedAt: timestamppb.Now(),
		},
		{
			Id:        "2",
			Email:     "user2@example.com",
			Username:  "user2",
			FullName:  "User Two",
			IsActive:  true,
			Roles:     []string{"user", "admin"},
			CreatedAt: timestamppb.Now(),
			UpdatedAt: timestamppb.Now(),
		},
	}

	total := int32(len(users))
	totalPages := (total + perPage - 1) / perPage

	return &userv1.ListUsersResponse{
		Users: users,
		Pagination: &commonv1.PaginationResponse{
			Page:       page,
			PerPage:    perPage,
			Total:      total,
			TotalPages: totalPages,
			HasNext:    page < totalPages,
			HasPrev:    page > 1,
		},
	}, nil
}

func (s *UserService) CreateUser(ctx context.Context, req *userv1.CreateUserRequest) (*userv1.CreateUserResponse, error) {
	if req.Email == "" {
		return nil, status.Error(codes.InvalidArgument, "email is required")
	}
	if req.Username == "" {
		return nil, status.Error(codes.InvalidArgument, "username is required")
	}
	if req.Password == "" {
		return nil, status.Error(codes.InvalidArgument, "password is required")
	}

	// TODO: Hash password and save to database
	user := &userv1.User{
		Id:        "generated-id",
		Email:     req.Email,
		Username:  req.Username,
		FullName:  req.FullName,
		IsActive:  true,
		Roles:     []string{"user"},
		CreatedAt: timestamppb.Now(),
		UpdatedAt: timestamppb.Now(),
	}

	return &userv1.CreateUserResponse{
		User: user,
	}, nil
}

func (s *UserService) UpdateUser(ctx context.Context, req *userv1.UpdateUserRequest) (*userv1.UpdateUserResponse, error) {
	if req.Id == "" {
		return nil, status.Error(codes.InvalidArgument, "user id is required")
	}

	// TODO: Update in database
	user := &userv1.User{
		Id:        req.Id,
		Email:     req.Email.GetValue(),
		Username:  req.Username.GetValue(),
		FullName:  req.FullName.GetValue(),
		AvatarUrl: req.AvatarUrl.GetValue(),
		IsActive:  req.IsActive.GetValue(),
		Roles:     req.Roles,
		UpdatedAt: timestamppb.Now(),
	}

	return &userv1.UpdateUserResponse{
		User: user,
	}, nil
}

func (s *UserService) DeleteUser(ctx context.Context, req *userv1.DeleteUserRequest) (*userv1.DeleteUserResponse, error) {
	if req.Id == "" {
		return nil, status.Error(codes.InvalidArgument, "user id is required")
	}

	// TODO: Delete from database
	return &userv1.DeleteUserResponse{
		Success: true,
	}, nil
}

func (s *UserService) StreamUsers(req *userv1.StreamUsersRequest, stream userv1.UserService_StreamUsersServer) error {
	// TODO: Stream users from database
	users := []*userv1.User{
		{
			Id:        "1",
			Email:     "user1@example.com",
			Username:  "user1",
			IsActive:  true,
			CreatedAt: timestamppb.Now(),
		},
		{
			Id:        "2",
			Email:     "user2@example.com",
			Username:  "user2",
			IsActive:  true,
			CreatedAt: timestamppb.Now(),
		},
	}

	for _, user := range users {
		if err := stream.Send(user); err != nil {
			return status.Error(codes.Internal, fmt.Sprintf("failed to send user: %v", err))
		}
	}

	return nil
}
