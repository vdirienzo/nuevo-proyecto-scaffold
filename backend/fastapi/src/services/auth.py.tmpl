# services/auth.py - Authentication Service
# Author: {{AUTHOR}}
# Project: {{PROJECT_NAME}}

"""
Authentication service for user registration, login, and token management.
"""

from passlib.context import CryptContext
from sqlmodel.ext.asyncio.session import AsyncSession

from ..models import User, UserCreate
from ..auth.jwt import decode_token
from .user import UserService


# Password hashing configuration
# Using bcrypt with automatic salt generation
pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12,  # Increase for production
)


class AuthService:
    """Service for authentication operations."""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.user_service = UserService(session)

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash a password using bcrypt."""
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """Verify a password against its hash."""
        return pwd_context.verify(plain_password, hashed_password)

    async def register_user(self, data: UserCreate) -> User:
        """
        Register a new user.

        Args:
            data: User creation data with plain password

        Returns:
            Created user instance
        """
        # Hash the password
        hashed_password = self.hash_password(data.password)

        # Create user model
        user = User(
            email=data.email.lower(),
            username=data.username.lower(),
            hashed_password=hashed_password,
            full_name=data.full_name,
        )

        self.session.add(user)
        await self.session.commit()
        await self.session.refresh(user)

        return user

    async def authenticate(
        self,
        username_or_email: str,
        password: str,
    ) -> User | None:
        """
        Authenticate user by username/email and password.

        Args:
            username_or_email: User's email or username
            password: Plain text password

        Returns:
            User if authenticated, None otherwise
        """
        # Try to find by email first, then by username
        user = await self.user_service.get_by_email(username_or_email)
        if not user:
            user = await self.user_service.get_by_username(username_or_email)

        if not user:
            # Perform dummy verification to prevent timing attacks
            self.verify_password(password, "$2b$12$dummy.hash.to.prevent.timing.attacks")
            return None

        if not self.verify_password(password, user.hashed_password):
            return None

        return user

    async def verify_refresh_token(self, token: str) -> User | None:
        """
        Verify a refresh token and return the associated user.

        Args:
            token: JWT refresh token

        Returns:
            User if token is valid, None otherwise
        """
        payload = decode_token(token)
        if not payload:
            return None

        user_id = payload.get("sub")
        token_type = payload.get("type")

        if not user_id or token_type != "refresh":
            return None

        user = await self.user_service.get_by_id(int(user_id))
        if not user or not user.is_active:
            return None

        return user
