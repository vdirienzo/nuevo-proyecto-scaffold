/*!
 * User service
 *
 * Author: {{AUTHOR}}
 */

use chrono::Utc;
use sqlx::PgPool;
use uuid::Uuid;

use crate::{
    error::{AppError, AppResult},
    models::user::{UpdateUserRequest, User, UserResponse},
};

pub struct UserService;

impl UserService {
    pub async fn get_all(pool: &PgPool) -> AppResult<Vec<UserResponse>> {
        let users = sqlx::query_as::<_, User>("SELECT * FROM users ORDER BY created_at DESC")
            .fetch_all(pool)
            .await?;

        Ok(users.into_iter().map(|u| u.into()).collect())
    }

    pub async fn get_by_id(pool: &PgPool, id: Uuid) -> AppResult<UserResponse> {
        let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(id)
            .fetch_optional(pool)
            .await?
            .ok_or_else(|| AppError::NotFound("User not found".to_string()))?;

        Ok(user.into())
    }

    pub async fn update(
        pool: &PgPool,
        id: Uuid,
        request: UpdateUserRequest,
    ) -> AppResult<UserResponse> {
        // Check if user exists
        let mut user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
            .bind(id)
            .fetch_optional(pool)
            .await?
            .ok_or_else(|| AppError::NotFound("User not found".to_string()))?;

        // Update fields
        if let Some(email) = request.email {
            user.email = email;
        }
        if let Some(username) = request.username {
            user.username = username;
        }
        user.updated_at = Utc::now();

        // Save to database
        let updated_user = sqlx::query_as::<_, User>(
            r#"
            UPDATE users
            SET email = $1, username = $2, updated_at = $3
            WHERE id = $4
            RETURNING *
            "#,
        )
        .bind(&user.email)
        .bind(&user.username)
        .bind(&user.updated_at)
        .bind(id)
        .fetch_one(pool)
        .await?;

        Ok(updated_user.into())
    }
}
