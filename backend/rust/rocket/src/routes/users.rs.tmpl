/*!
 * User routes
 *
 * Author: {{AUTHOR}}
 */

use rocket::{serde::json::Json, State};
use sqlx::PgPool;
use uuid::Uuid;
use validator::Validate;

use crate::{
    db::Database,
    error::{AppError, AppResult},
    models::user::{UpdateUserRequest, User, UserResponse},
};

async fn get_all_users(pool: &PgPool) -> AppResult<Vec<UserResponse>> {
    let users = sqlx::query_as::<_, User>("SELECT * FROM users ORDER BY created_at DESC")
        .fetch_all(pool)
        .await?;

    Ok(users.into_iter().map(|u| u.into()).collect())
}

async fn get_user_by_id(pool: &PgPool, id: Uuid) -> AppResult<UserResponse> {
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(id)
        .fetch_optional(pool)
        .await?
        .ok_or_else(|| AppError::NotFound("User not found".to_string()))?;

    Ok(user.into())
}

async fn update_user_by_id(
    pool: &PgPool,
    id: Uuid,
    request: UpdateUserRequest,
) -> AppResult<UserResponse> {
    let mut user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(id)
        .fetch_optional(pool)
        .await?
        .ok_or_else(|| AppError::NotFound("User not found".to_string()))?;

    if let Some(email) = request.email {
        user.email = email;
    }
    if let Some(username) = request.username {
        user.username = username;
    }
    user.updated_at = chrono::Utc::now();

    let updated_user = sqlx::query_as::<_, User>(
        r#"
        UPDATE users
        SET email = $1, username = $2, updated_at = $3
        WHERE id = $4
        RETURNING *
        "#,
    )
    .bind(&user.email)
    .bind(&user.username)
    .bind(&user.updated_at)
    .bind(id)
    .fetch_one(pool)
    .await?;

    Ok(updated_user.into())
}

#[utoipa::path(
    get,
    path = "/api/v1/users",
    tag = "users",
    responses(
        (status = 200, description = "List of users", body = Vec<UserResponse>)
    )
)]
#[get("/users")]
pub async fn get_users(db: &State<Database>) -> Result<Json<Vec<UserResponse>>, AppError> {
    let users = get_all_users(db.pool()).await?;
    Ok(Json(users))
}

#[utoipa::path(
    get,
    path = "/api/v1/users/{id}",
    tag = "users",
    params(
        ("id" = Uuid, Path, description = "User ID")
    ),
    responses(
        (status = 200, description = "User found", body = UserResponse),
        (status = 404, description = "User not found")
    )
)]
#[get("/users/<id>")]
pub async fn get_user(db: &State<Database>, id: Uuid) -> Result<Json<UserResponse>, AppError> {
    let user = get_user_by_id(db.pool(), id).await?;
    Ok(Json(user))
}

#[utoipa::path(
    put,
    path = "/api/v1/users/{id}",
    tag = "users",
    params(
        ("id" = Uuid, Path, description = "User ID")
    ),
    request_body = UpdateUserRequest,
    responses(
        (status = 200, description = "User updated", body = UserResponse),
        (status = 400, description = "Validation error"),
        (status = 404, description = "User not found")
    )
)]
#[put("/users/<id>", data = "<request>")]
pub async fn update_user(
    db: &State<Database>,
    id: Uuid,
    request: Json<UpdateUserRequest>,
) -> Result<Json<UserResponse>, AppError> {
    request.validate().map_err(|e| AppError::Validation(e.to_string()))?;

    let user = update_user_by_id(db.pool(), id, request.into_inner()).await?;
    Ok(Json(user))
}
