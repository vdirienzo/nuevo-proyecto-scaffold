/*!
 * Error handling
 *
 * Author: {{AUTHOR}}
 */

use rocket::{http::Status, response::Responder, serde::json::Json, Request, Response};
use serde::Serialize;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    #[error("Authentication error: {0}")]
    Authentication(String),

    #[error("Authorization error: {0}")]
    Authorization(String),

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Not found: {0}")]
    NotFound(String),

    #[error("Conflict: {0}")]
    Conflict(String),

    #[error("Internal server error: {0}")]
    Internal(String),

    #[error("JWT error: {0}")]
    Jwt(#[from] jsonwebtoken::errors::Error),

    #[error("Argon2 error: {0}")]
    Argon2(#[from] argon2::password_hash::Error),
}

#[derive(Serialize)]
struct ErrorResponse {
    error: String,
    message: String,
}

impl<'r> Responder<'r, 'static> for AppError {
    fn respond_to(self, _: &'r Request<'_>) -> rocket::response::Result<'static> {
        let status = match self {
            AppError::Database(_) => Status::InternalServerError,
            AppError::Authentication(_) => Status::Unauthorized,
            AppError::Authorization(_) => Status::Forbidden,
            AppError::Validation(_) => Status::BadRequest,
            AppError::NotFound(_) => Status::NotFound,
            AppError::Conflict(_) => Status::Conflict,
            AppError::Internal(_) => Status::InternalServerError,
            AppError::Jwt(_) => Status::Unauthorized,
            AppError::Argon2(_) => Status::InternalServerError,
        };

        let error_response = ErrorResponse {
            error: status.to_string(),
            message: self.to_string(),
        };

        Response::build()
            .status(status)
            .sized_body(None, std::io::Cursor::new(serde_json::to_string(&error_response).unwrap()))
            .ok()
    }
}

pub type AppResult<T> = Result<T, AppError>;
