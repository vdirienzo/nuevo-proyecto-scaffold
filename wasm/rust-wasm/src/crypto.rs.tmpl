/**
 * crypto.rs - Cryptographic operations
 *
 * High-performance cryptographic functions for browser environments.
 *
 * Author: {{AUTHOR}}
 */

use wasm_bindgen::prelude::*;
use sha2::{Sha256, Sha512, Digest};
use blake3::Hasher as Blake3Hasher;

/// SHA-256 hash
#[wasm_bindgen]
pub fn sha256(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

/// SHA-256 hash returning hex string
#[wasm_bindgen]
pub fn sha256_hex(data: &[u8]) -> String {
    let hash = sha256(data);
    crate::utils::bytes_to_hex(&hash)
}

/// SHA-512 hash
#[wasm_bindgen]
pub fn sha512(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha512::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

/// SHA-512 hash returning hex string
#[wasm_bindgen]
pub fn sha512_hex(data: &[u8]) -> String {
    let hash = sha512(data);
    crate::utils::bytes_to_hex(&hash)
}

/// BLAKE3 hash (faster than SHA-2)
#[wasm_bindgen]
pub fn blake3_hash(data: &[u8]) -> Vec<u8> {
    let mut hasher = Blake3Hasher::new();
    hasher.update(data);
    hasher.finalize().as_bytes().to_vec()
}

/// BLAKE3 hash returning hex string
#[wasm_bindgen]
pub fn blake3_hash_hex(data: &[u8]) -> String {
    let hash = blake3_hash(data);
    crate::utils::bytes_to_hex(&hash)
}

/// Simple XOR cipher (for demonstration - NOT secure for production)
#[wasm_bindgen]
pub fn xor_cipher(data: &[u8], key: &[u8]) -> Result<Vec<u8>, JsValue> {
    if key.is_empty() {
        return Err(JsValue::from_str("Key cannot be empty"));
    }

    let result: Vec<u8> = data.iter()
        .enumerate()
        .map(|(i, &byte)| byte ^ key[i % key.len()])
        .collect();

    Ok(result)
}

/// Hash password with salt (PBKDF2-like simple implementation)
#[wasm_bindgen]
pub fn hash_password(password: &str, salt: &[u8], iterations: u32) -> Result<Vec<u8>, JsValue> {
    if iterations == 0 {
        return Err(JsValue::from_str("Iterations must be > 0"));
    }

    let mut result = password.as_bytes().to_vec();
    result.extend_from_slice(salt);

    for _ in 0..iterations {
        result = sha256(&result);
    }

    Ok(result)
}

/// Generate a cryptographic fingerprint of data
#[wasm_bindgen]
pub fn fingerprint(data: &[u8]) -> String {
    let hash = blake3_hash(data);
    // Take first 16 bytes and format as fingerprint
    let fingerprint_bytes = &hash[..16];

    fingerprint_bytes
        .chunks(2)
        .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
        .collect::<Vec<_>>()
        .join(":")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sha256() {
        let data = b"hello world";
        let hash = sha256_hex(data);
        // Known SHA-256 hash of "hello world"
        assert_eq!(hash.len(), 64);
    }

    #[test]
    fn test_xor_cipher() {
        let data = b"secret message";
        let key = b"key";

        let encrypted = xor_cipher(data, key).unwrap();
        let decrypted = xor_cipher(&encrypted, key).unwrap();

        assert_eq!(data.to_vec(), decrypted);
    }

    #[test]
    fn test_fingerprint() {
        let data = b"test data";
        let fp = fingerprint(data);
        assert!(fp.contains(":"));
        assert!(fp.len() > 0);
    }
}
