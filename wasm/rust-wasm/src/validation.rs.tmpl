/**
 * validation.rs - Data validation operations
 *
 * Fast data validation and sanitization functions.
 *
 * Author: {{AUTHOR}}
 */

use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json;

/// Validate email address
#[wasm_bindgen]
pub fn validate_email(email: &str) -> bool {
    if email.is_empty() || email.len() > 254 {
        return false;
    }

    let parts: Vec<&str> = email.split('@').collect();
    if parts.len() != 2 {
        return false;
    }

    let local = parts[0];
    let domain = parts[1];

    // Basic validation
    !local.is_empty()
        && !domain.is_empty()
        && domain.contains('.')
        && !domain.starts_with('.')
        && !domain.ends_with('.')
}

/// Validate URL
#[wasm_bindgen]
pub fn validate_url(url: &str) -> bool {
    if url.is_empty() {
        return false;
    }

    url.starts_with("http://") || url.starts_with("https://")
}

/// Validate phone number (basic international format)
#[wasm_bindgen]
pub fn validate_phone(phone: &str) -> bool {
    let cleaned: String = phone.chars()
        .filter(|c| c.is_numeric() || *c == '+')
        .collect();

    cleaned.len() >= 10 && cleaned.len() <= 15
}

/// Validate credit card number using Luhn algorithm
#[wasm_bindgen]
pub fn validate_credit_card(number: &str) -> bool {
    let cleaned: String = number.chars().filter(|c| c.is_numeric()).collect();

    if cleaned.len() < 13 || cleaned.len() > 19 {
        return false;
    }

    luhn_check(&cleaned)
}

fn luhn_check(number: &str) -> bool {
    let mut sum = 0;
    let mut double = false;

    for c in number.chars().rev() {
        if let Some(mut digit) = c.to_digit(10) {
            if double {
                digit *= 2;
                if digit > 9 {
                    digit -= 9;
                }
            }
            sum += digit;
            double = !double;
        } else {
            return false;
        }
    }

    sum % 10 == 0
}

/// Validate JSON string
#[wasm_bindgen]
pub fn validate_json(json_str: &str) -> bool {
    serde_json::from_str::<serde_json::Value>(json_str).is_ok()
}

/// Sanitize HTML (basic XSS prevention)
#[wasm_bindgen]
pub fn sanitize_html(html: &str) -> String {
    html.replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
        .replace('&', "&amp;")
}

/// Validate password strength (returns score 0-4)
#[wasm_bindgen]
pub fn password_strength(password: &str) -> u8 {
    let mut score = 0u8;

    // Length
    if password.len() >= 8 {
        score += 1;
    }
    if password.len() >= 12 {
        score += 1;
    }

    // Complexity
    let has_lowercase = password.chars().any(|c| c.is_lowercase());
    let has_uppercase = password.chars().any(|c| c.is_uppercase());
    let has_digit = password.chars().any(|c| c.is_numeric());
    let has_special = password.chars().any(|c| !c.is_alphanumeric());

    if has_lowercase && has_uppercase {
        score += 1;
    }
    if has_digit {
        score += 1;
    }
    if has_special {
        score += 1;
    }

    score.min(4)
}

/// Validate username (alphanumeric + underscore, 3-20 chars)
#[wasm_bindgen]
pub fn validate_username(username: &str) -> bool {
    if username.len() < 3 || username.len() > 20 {
        return false;
    }

    username.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-')
}

/// Validate IPv4 address
#[wasm_bindgen]
pub fn validate_ipv4(ip: &str) -> bool {
    let parts: Vec<&str> = ip.split('.').collect();

    if parts.len() != 4 {
        return false;
    }

    parts.iter().all(|part| {
        part.parse::<u8>().is_ok()
    })
}

/// Validate hex color (#RGB or #RRGGBB)
#[wasm_bindgen]
pub fn validate_hex_color(color: &str) -> bool {
    if !color.starts_with('#') {
        return false;
    }

    let hex = &color[1..];
    (hex.len() == 3 || hex.len() == 6) && hex.chars().all(|c| c.is_ascii_hexdigit())
}

/// Check if string contains only ASCII
#[wasm_bindgen]
pub fn is_ascii(text: &str) -> bool {
    text.is_ascii()
}

/// Validate JSON against simple schema
#[wasm_bindgen]
pub fn validate_json_schema(json_str: &str, required_fields: Vec<JsValue>) -> Result<bool, JsValue> {
    let value: serde_json::Value = serde_json::from_str(json_str)
        .map_err(|e| JsValue::from_str(&format!("Invalid JSON: {}", e)))?;

    if let Some(obj) = value.as_object() {
        for field in required_fields {
            if let Some(field_name) = field.as_string() {
                if !obj.contains_key(&field_name) {
                    return Ok(false);
                }
            }
        }
        Ok(true)
    } else {
        Ok(false)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_email() {
        assert!(validate_email("test@example.com"));
        assert!(validate_email("user.name+tag@example.co.uk"));
        assert!(!validate_email("invalid"));
        assert!(!validate_email("@example.com"));
        assert!(!validate_email("test@"));
    }

    #[test]
    fn test_validate_url() {
        assert!(validate_url("https://example.com"));
        assert!(validate_url("http://localhost:3000"));
        assert!(!validate_url("ftp://example.com"));
        assert!(!validate_url("example.com"));
    }

    #[test]
    fn test_luhn_check() {
        // Valid test card number
        assert!(validate_credit_card("4532015112830366"));
        assert!(!validate_credit_card("1234567890123456"));
    }

    #[test]
    fn test_password_strength() {
        assert_eq!(password_strength("weak"), 1);
        assert_eq!(password_strength("StrongPass123!"), 4);
        assert_eq!(password_strength("12345678"), 1);
    }

    #[test]
    fn test_sanitize_html() {
        let dirty = "<script>alert('xss')</script>";
        let clean = sanitize_html(dirty);
        assert!(!clean.contains('<'));
        assert!(!clean.contains('>'));
    }
}
