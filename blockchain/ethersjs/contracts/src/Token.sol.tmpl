// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import {ERC20Votes} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title {{PROJECT_NAME}} Token
 * @author {{AUTHOR}}
 * @notice ERC20 token with permit, votes, and burn capabilities
 * @dev Extends OpenZeppelin's ERC20, ERC20Permit, ERC20Votes, and Ownable
 */
contract Token is ERC20, ERC20Permit, ERC20Votes, Ownable {
    /// @notice Maximum supply cap
    uint256 public immutable MAX_SUPPLY;

    /// @notice Emitted when tokens are burned
    event TokensBurned(address indexed from, uint256 amount);

    /// @notice Emitted when tokens are minted
    event TokensMinted(address indexed to, uint256 amount);

    /**
     * @notice Constructor
     * @param name Token name
     * @param symbol Token symbol
     * @param maxSupply Maximum supply (0 for unlimited)
     * @param initialSupply Initial supply to mint to deployer
     */
    constructor(
        string memory name,
        string memory symbol,
        uint256 maxSupply,
        uint256 initialSupply
    ) ERC20(name, symbol) ERC20Permit(name) Ownable(msg.sender) {
        MAX_SUPPLY = maxSupply;

        if (initialSupply > 0) {
            if (maxSupply > 0 && initialSupply > maxSupply) {
                revert("Initial supply exceeds max supply");
            }
            _mint(msg.sender, initialSupply);
            emit TokensMinted(msg.sender, initialSupply);
        }
    }

    /**
     * @notice Mint new tokens (only owner)
     * @param to Recipient address
     * @param amount Amount to mint
     */
    function mint(address to, uint256 amount) external onlyOwner {
        if (MAX_SUPPLY > 0 && totalSupply() + amount > MAX_SUPPLY) {
            revert("Exceeds max supply");
        }
        _mint(to, amount);
        emit TokensMinted(to, amount);
    }

    /**
     * @notice Burn tokens from caller's balance
     * @param amount Amount to burn
     */
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
        emit TokensBurned(msg.sender, amount);
    }

    /**
     * @notice Burn tokens from specified account (requires approval)
     * @param from Account to burn from
     * @param amount Amount to burn
     */
    function burnFrom(address from, uint256 amount) external {
        _spendAllowance(from, msg.sender, amount);
        _burn(from, amount);
        emit TokensBurned(from, amount);
    }

    // Required overrides

    function _update(address from, address to, uint256 value)
        internal
        override(ERC20, ERC20Votes)
    {
        super._update(from, to, value);
    }

    function nonces(address owner)
        public
        view
        override(ERC20Permit, Nonces)
        returns (uint256)
    {
        return super.nonces(owner);
    }
}
