// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title {{PROJECT_NAME}} Staking
 * @author {{AUTHOR}}
 * @notice Staking contract with rewards
 * @dev Users stake tokens and earn rewards over time
 */
contract Staking is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    /// @notice Staking token
    IERC20 public immutable stakingToken;

    /// @notice Reward token
    IERC20 public immutable rewardToken;

    /// @notice Reward rate per second (in wei)
    uint256 public rewardRate;

    /// @notice Last update timestamp
    uint256 public lastUpdateTime;

    /// @notice Accumulated reward per token
    uint256 public rewardPerTokenStored;

    /// @notice Total staked amount
    uint256 public totalStaked;

    /// @notice User stakes
    struct Stake {
        uint256 amount;
        uint256 rewardPerTokenPaid;
        uint256 rewards;
        uint256 stakedAt;
    }

    mapping(address => Stake) public stakes;

    /// @notice Minimum stake amount
    uint256 public minStakeAmount;

    /// @notice Lock period in seconds
    uint256 public lockPeriod;

    // Events
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardRateUpdated(uint256 newRate);
    event LockPeriodUpdated(uint256 newPeriod);

    /**
     * @notice Constructor
     * @param _stakingToken Staking token address
     * @param _rewardToken Reward token address
     * @param _rewardRate Initial reward rate per second
     * @param _minStakeAmount Minimum stake amount
     * @param _lockPeriod Lock period in seconds
     */
    constructor(
        address _stakingToken,
        address _rewardToken,
        uint256 _rewardRate,
        uint256 _minStakeAmount,
        uint256 _lockPeriod
    ) Ownable(msg.sender) {
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
        minStakeAmount = _minStakeAmount;
        lockPeriod = _lockPeriod;
        lastUpdateTime = block.timestamp;
    }

    /**
     * @notice Calculate reward per token
     */
    function rewardPerToken() public view returns (uint256) {
        if (totalStaked == 0) {
            return rewardPerTokenStored;
        }

        return
            rewardPerTokenStored +
            (((block.timestamp - lastUpdateTime) * rewardRate * 1e18) / totalStaked);
    }

    /**
     * @notice Calculate earned rewards for user
     * @param account User address
     */
    function earned(address account) public view returns (uint256) {
        Stake memory userStake = stakes[account];
        return
            ((userStake.amount * (rewardPerToken() - userStake.rewardPerTokenPaid)) / 1e18) +
            userStake.rewards;
    }

    /**
     * @notice Update reward variables
     */
    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = block.timestamp;

        if (account != address(0)) {
            stakes[account].rewards = earned(account);
            stakes[account].rewardPerTokenPaid = rewardPerTokenStored;
        }
        _;
    }

    /**
     * @notice Stake tokens
     * @param amount Amount to stake
     */
    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {
        require(amount >= minStakeAmount, "Below minimum stake");

        stakes[msg.sender].amount += amount;
        stakes[msg.sender].stakedAt = block.timestamp;
        totalStaked += amount;

        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        emit Staked(msg.sender, amount);
    }

    /**
     * @notice Withdraw staked tokens
     * @param amount Amount to withdraw
     */
    function withdraw(uint256 amount) external nonReentrant updateReward(msg.sender) {
        Stake storage userStake = stakes[msg.sender];
        require(userStake.amount >= amount, "Insufficient balance");
        require(
            block.timestamp >= userStake.stakedAt + lockPeriod,
            "Lock period not expired"
        );

        userStake.amount -= amount;
        totalStaked -= amount;

        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }

    /**
     * @notice Claim rewards
     */
    function claimReward() external nonReentrant updateReward(msg.sender) {
        uint256 reward = stakes[msg.sender].rewards;
        require(reward > 0, "No rewards");

        stakes[msg.sender].rewards = 0;
        rewardToken.safeTransfer(msg.sender, reward);
        emit RewardPaid(msg.sender, reward);
    }

    /**
     * @notice Exit: withdraw all and claim rewards
     */
    function exit() external {
        withdraw(stakes[msg.sender].amount);
        claimReward();
    }

    /**
     * @notice Set reward rate (only owner)
     * @param _rewardRate New reward rate per second
     */
    function setRewardRate(uint256 _rewardRate) external onlyOwner updateReward(address(0)) {
        rewardRate = _rewardRate;
        emit RewardRateUpdated(_rewardRate);
    }

    /**
     * @notice Set lock period (only owner)
     * @param _lockPeriod New lock period in seconds
     */
    function setLockPeriod(uint256 _lockPeriod) external onlyOwner {
        lockPeriod = _lockPeriod;
        emit LockPeriodUpdated(_lockPeriod);
    }

    /**
     * @notice Get user stake info
     * @param account User address
     */
    function getStakeInfo(address account)
        external
        view
        returns (
            uint256 amount,
            uint256 rewards,
            uint256 stakedAt,
            bool canWithdraw
        )
    {
        Stake memory userStake = stakes[account];
        return (
            userStake.amount,
            earned(account),
            userStake.stakedAt,
            block.timestamp >= userStake.stakedAt + lockPeriod
        );
    }
}
