/**
 * @fileoverview EIP-712 typed data signing utilities
 * @author {{AUTHOR}}
 */

import { TypedDataDomain, TypedDataField, Signer } from 'ethers';
import { getSigner } from '../providers/ethers-provider';

/**
 * EIP-712 domain
 */
export interface Domain extends TypedDataDomain {
  name: string;
  version: string;
  chainId: number;
  verifyingContract: string;
}

/**
 * Sign typed data (EIP-712)
 */
export async function signTypedData(
  domain: Domain,
  types: Record<string, TypedDataField[]>,
  value: Record<string, unknown>
): Promise<string> {
  const signer = await getSigner();
  return await signer.signTypedData(domain, types, value);
}

/**
 * Create EIP-712 domain
 */
export function createDomain(
  name: string,
  version: string,
  chainId: number,
  verifyingContract: string
): Domain {
  return {
    name,
    version,
    chainId,
    verifyingContract,
  };
}

/**
 * ERC-2612 Permit signature
 */
export interface PermitSignature {
  v: number;
  r: string;
  s: string;
  deadline: number;
}

/**
 * Sign ERC-2612 permit
 */
export async function signPermit(
  tokenAddress: string,
  owner: string,
  spender: string,
  value: bigint,
  nonce: bigint,
  deadline: number,
  chainId: number
): Promise<PermitSignature> {
  const domain = createDomain('Token', '1', chainId, tokenAddress);

  const types = {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
    ],
  };

  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline,
  };

  const signature = await signTypedData(domain, types, message);

  // Split signature
  const r = signature.slice(0, 66);
  const s = '0x' + signature.slice(66, 130);
  const v = parseInt(signature.slice(130, 132), 16);

  return { v, r, s, deadline };
}

/**
 * Meta-transaction signature
 */
export interface MetaTxSignature {
  signature: string;
  nonce: bigint;
}

/**
 * Sign meta-transaction (EIP-2771)
 */
export async function signMetaTransaction(
  from: string,
  to: string,
  value: bigint,
  data: string,
  nonce: bigint,
  chainId: number,
  verifyingContract: string
): Promise<MetaTxSignature> {
  const domain = createDomain('MetaTx', '1', chainId, verifyingContract);

  const types = {
    MetaTransaction: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'data', type: 'bytes' },
      { name: 'nonce', type: 'uint256' },
    ],
  };

  const message = {
    from,
    to,
    value,
    data,
    nonce,
  };

  const signature = await signTypedData(domain, types, message);

  return { signature, nonce };
}

/**
 * Sign message for verification
 */
export async function signMessage(message: string): Promise<string> {
  const signer = await getSigner();
  return await signer.signMessage(message);
}

/**
 * Create typed data hash
 */
export function hashTypedData(
  domain: Domain,
  types: Record<string, TypedDataField[]>,
  value: Record<string, unknown>
): string {
  // This would require the full EIP-712 hashing implementation
  // For now, return a placeholder
  // In production, use ethers.TypedDataEncoder.hash()
  return '0x';
}

/**
 * Vote signature for governance
 */
export async function signVote(
  governanceAddress: string,
  proposalId: bigint,
  support: number,
  chainId: number
): Promise<string> {
  const domain = createDomain('Governance', '1', chainId, governanceAddress);

  const types = {
    Ballot: [
      { name: 'proposalId', type: 'uint256' },
      { name: 'support', type: 'uint8' },
    ],
  };

  const message = {
    proposalId,
    support,
  };

  return await signTypedData(domain, types, message);
}
