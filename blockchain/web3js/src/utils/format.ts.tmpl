/**
 * Formatting utilities for {{PROJECT_NAME}}
 * Helper functions for formatting blockchain data
 *
 * @author {{AUTHOR}}
 */

import { web3Provider } from "../services/web3-provider";

/**
 * Format Wei to Ether
 */
export function formatEther(wei: string | bigint): string {
  const web3 = web3Provider.getWeb3();
  return web3.utils.fromWei(wei, "ether");
}

/**
 * Format Ether to Wei
 */
export function parseEther(ether: string): bigint {
  const web3 = web3Provider.getWeb3();
  return web3.utils.toWei(ether, "ether");
}

/**
 * Format Wei to Gwei
 */
export function formatGwei(wei: string | bigint): string {
  const web3 = web3Provider.getWeb3();
  return web3.utils.fromWei(wei, "gwei");
}

/**
 * Format Gwei to Wei
 */
export function parseGwei(gwei: string): bigint {
  const web3 = web3Provider.getWeb3();
  return web3.utils.toWei(gwei, "gwei");
}

/**
 * Format address for display (0x1234...5678)
 */
export function formatAddress(address: string, startChars: number = 6, endChars: number = 4): string {
  if (!address) return "";
  if (address.length <= startChars + endChars) return address;

  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;
}

/**
 * Format transaction hash for display
 */
export function formatTxHash(hash: string, chars: number = 10): string {
  if (!hash) return "";
  if (hash.length <= chars * 2) return hash;

  return `${hash.slice(0, chars)}...${hash.slice(-chars)}`;
}

/**
 * Format number with commas
 */
export function formatNumber(num: number | string, decimals: number = 2): string {
  const number = typeof num === "string" ? parseFloat(num) : num;

  if (isNaN(number)) return "0";

  return number.toLocaleString("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: decimals,
  });
}

/**
 * Format token amount with symbol
 */
export function formatTokenAmount(
  amount: string | bigint,
  symbol: string,
  decimals: number = 18,
  displayDecimals: number = 4
): string {
  const web3 = web3Provider.getWeb3();
  const formatted = web3.utils.fromWei(amount, "ether");
  const number = parseFloat(formatted);

  return `${formatNumber(number, displayDecimals)} ${symbol}`;
}

/**
 * Format USD value
 */
export function formatUSD(amount: number, showSymbol: boolean = true): string {
  const formatted = amount.toLocaleString("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });

  return showSymbol ? `$${formatted}` : formatted;
}

/**
 * Format percentage
 */
export function formatPercentage(value: number, decimals: number = 2): string {
  return `${value.toFixed(decimals)}%`;
}

/**
 * Format timestamp to date string
 */
export function formatTimestamp(timestamp: number, includeTime: boolean = true): string {
  const date = new Date(timestamp * 1000);

  if (includeTime) {
    return date.toLocaleString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }

  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}

/**
 * Format time ago (e.g., "2 hours ago")
 */
export function formatTimeAgo(timestamp: number): string {
  const now = Date.now();
  const seconds = Math.floor((now - timestamp * 1000) / 1000);

  if (seconds < 60) return `${seconds} seconds ago`;

  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} minute${minutes > 1 ? "s" : ""} ago`;

  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hour${hours > 1 ? "s" : ""} ago`;

  const days = Math.floor(hours / 24);
  if (days < 30) return `${days} day${days > 1 ? "s" : ""} ago`;

  const months = Math.floor(days / 30);
  if (months < 12) return `${months} month${months > 1 ? "s" : ""} ago`;

  const years = Math.floor(months / 12);
  return `${years} year${years > 1 ? "s" : ""} ago`;
}

/**
 * Format gas price for display
 */
export function formatGasPrice(gasPrice: bigint): string {
  const gwei = formatGwei(gasPrice);
  return `${parseFloat(gwei).toFixed(2)} Gwei`;
}

/**
 * Truncate text with ellipsis
 */
export function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + "...";
}

/**
 * Format large numbers with K/M/B suffix
 */
export function formatCompactNumber(num: number): string {
  if (num < 1000) return num.toString();
  if (num < 1000000) return `${(num / 1000).toFixed(1)}K`;
  if (num < 1000000000) return `${(num / 1000000).toFixed(1)}M`;
  return `${(num / 1000000000).toFixed(1)}B`;
}
