/**
 * useWallet Hook for {{PROJECT_NAME}}
 * React hook for wallet connection and management
 *
 * @author {{AUTHOR}}
 */

import { useState, useEffect, useCallback } from "react";
import { walletService, WalletAccount } from "../services/wallet-service";
import { web3Provider } from "../services/web3-provider";

export interface WalletState {
  account: string | null;
  accounts: string[];
  balance: string | null;
  balanceFormatted: string | null;
  isConnected: boolean;
  isConnecting: boolean;
  error: Error | null;
}

export type WalletProvider = "metamask" | "walletconnect";

export function useWallet() {
  const [state, setState] = useState<WalletState>({
    account: null,
    accounts: [],
    balance: null,
    balanceFormatted: null,
    isConnected: false,
    isConnecting: false,
    error: null,
  });

  const connect = useCallback(async (provider: WalletProvider = "metamask") => {
    setState((prev) => ({ ...prev, isConnecting: true, error: null }));

    try {
      let account: string;

      if (provider === "metamask") {
        account = await walletService.connectMetaMask();
      } else {
        account = await walletService.connectWalletConnect();
      }

      const accounts = await walletService.getAccounts();
      const accountInfo = await walletService.getAccountInfo(account);

      setState({
        account,
        accounts,
        balance: accountInfo.balance,
        balanceFormatted: accountInfo.balanceFormatted,
        isConnected: true,
        isConnecting: false,
        error: null,
      });

      return account;
    } catch (error) {
      setState((prev) => ({
        ...prev,
        isConnecting: false,
        error: error as Error,
      }));
      throw error;
    }
  }, []);

  const disconnect = useCallback(async () => {
    await walletService.disconnect();
    setState({
      account: null,
      accounts: [],
      balance: null,
      balanceFormatted: null,
      isConnected: false,
      isConnecting: false,
      error: null,
    });
  }, []);

  const refreshBalance = useCallback(async () => {
    if (!state.account) return;

    try {
      const accountInfo = await walletService.getAccountInfo(state.account);
      setState((prev) => ({
        ...prev,
        balance: accountInfo.balance,
        balanceFormatted: accountInfo.balanceFormatted,
      }));
    } catch (error) {
      console.error("Failed to refresh balance:", error);
    }
  }, [state.account]);

  const signMessage = useCallback(
    async (message: string): Promise<string> => {
      if (!state.account) {
        throw new Error("No account connected");
      }

      return await walletService.signMessage(message, state.account);
    },
    [state.account]
  );

  const addToken = useCallback(
    async (
      tokenAddress: string,
      tokenSymbol: string,
      tokenDecimals: number,
      tokenImage?: string
    ): Promise<boolean> => {
      return await walletService.addToken(
        tokenAddress,
        tokenSymbol,
        tokenDecimals,
        tokenImage
      );
    },
    []
  );

  // Subscribe to account changes
  useEffect(() => {
    if (!web3Provider.isInitialized()) return;

    const handleAccountsChanged = async (accounts: string[]) => {
      if (accounts.length === 0) {
        // User disconnected
        setState({
          account: null,
          accounts: [],
          balance: null,
          balanceFormatted: null,
          isConnected: false,
          isConnecting: false,
          error: null,
        });
      } else {
        // Account changed
        const newAccount = accounts[0];
        const accountInfo = await walletService.getAccountInfo(newAccount);

        setState((prev) => ({
          ...prev,
          account: newAccount,
          accounts,
          balance: accountInfo.balance,
          balanceFormatted: accountInfo.balanceFormatted,
        }));
      }
    };

    web3Provider.subscribeToEvents({
      onAccountsChanged: handleAccountsChanged,
    });
  }, []);

  // Auto-refresh balance
  useEffect(() => {
    if (!state.account) return;

    const interval = setInterval(refreshBalance, 30000); // Every 30 seconds

    return () => clearInterval(interval);
  }, [state.account, refreshBalance]);

  return {
    ...state,
    connect,
    disconnect,
    refreshBalance,
    signMessage,
    addToken,
  };
}
