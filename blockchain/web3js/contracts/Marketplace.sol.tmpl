// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title {{PROJECT_NAME}} NFT Marketplace
 * @dev Marketplace for buying and selling NFTs with support for ETH and ERC20 tokens
 * @author {{AUTHOR}}
 */
contract {{PROJECT_NAME}}Marketplace is ReentrancyGuard, Ownable {
    struct Listing {
        address seller;
        address nftContract;
        uint256 tokenId;
        uint256 price;
        address paymentToken; // address(0) for ETH
        bool active;
    }

    struct Offer {
        address buyer;
        uint256 price;
        address paymentToken;
        uint256 expiresAt;
        bool active;
    }

    // Marketplace fee (in basis points, e.g., 250 = 2.5%)
    uint256 public feePercent = 250;
    uint256 public constant MAX_FEE = 1000; // 10% max fee

    // Listing ID => Listing
    mapping(uint256 => Listing) public listings;
    uint256 public listingCounter;

    // NFT Contract => Token ID => Listing ID
    mapping(address => mapping(uint256 => uint256)) public nftToListing;

    // Listing ID => Offer ID => Offer
    mapping(uint256 => mapping(uint256 => Offer)) public offers;
    mapping(uint256 => uint256) public offerCounter;

    event NFTListed(
        uint256 indexed listingId,
        address indexed seller,
        address indexed nftContract,
        uint256 tokenId,
        uint256 price,
        address paymentToken
    );

    event NFTSold(
        uint256 indexed listingId,
        address indexed buyer,
        address indexed seller,
        uint256 price
    );

    event ListingCancelled(uint256 indexed listingId);

    event OfferMade(
        uint256 indexed listingId,
        uint256 indexed offerId,
        address indexed buyer,
        uint256 price
    );

    event OfferAccepted(uint256 indexed listingId, uint256 indexed offerId);
    event OfferCancelled(uint256 indexed listingId, uint256 indexed offerId);
    event FeeUpdated(uint256 oldFee, uint256 newFee);

    constructor() Ownable(msg.sender) {}

    /**
     * @dev List an NFT for sale
     * @param nftContract Address of the NFT contract
     * @param tokenId Token ID of the NFT
     * @param price Listing price
     * @param paymentToken Address of payment token (address(0) for ETH)
     */
    function listNFT(
        address nftContract,
        uint256 tokenId,
        uint256 price,
        address paymentToken
    ) external nonReentrant {
        require(price > 0, "Price must be greater than 0");

        IERC721 nft = IERC721(nftContract);
        require(nft.ownerOf(tokenId) == msg.sender, "Not the NFT owner");
        require(
            nft.isApprovedForAll(msg.sender, address(this)) ||
            nft.getApproved(tokenId) == address(this),
            "Marketplace not approved"
        );

        uint256 listingId = listingCounter++;

        listings[listingId] = Listing({
            seller: msg.sender,
            nftContract: nftContract,
            tokenId: tokenId,
            price: price,
            paymentToken: paymentToken,
            active: true
        });

        nftToListing[nftContract][tokenId] = listingId;

        emit NFTListed(listingId, msg.sender, nftContract, tokenId, price, paymentToken);
    }

    /**
     * @dev Buy a listed NFT
     * @param listingId ID of the listing
     */
    function buyNFT(uint256 listingId) external payable nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(msg.sender != listing.seller, "Cannot buy your own NFT");

        uint256 totalPrice = listing.price;
        uint256 fee = (totalPrice * feePercent) / 10000;
        uint256 sellerAmount = totalPrice - fee;

        if (listing.paymentToken == address(0)) {
            // ETH payment
            require(msg.value >= totalPrice, "Insufficient payment");

            payable(listing.seller).transfer(sellerAmount);

            // Refund excess
            if (msg.value > totalPrice) {
                payable(msg.sender).transfer(msg.value - totalPrice);
            }
        } else {
            // ERC20 payment
            IERC20 token = IERC20(listing.paymentToken);
            require(
                token.transferFrom(msg.sender, listing.seller, sellerAmount),
                "Token transfer to seller failed"
            );
            require(
                token.transferFrom(msg.sender, owner(), fee),
                "Token fee transfer failed"
            );
        }

        // Transfer NFT
        IERC721(listing.nftContract).safeTransferFrom(
            listing.seller,
            msg.sender,
            listing.tokenId
        );

        listing.active = false;
        delete nftToListing[listing.nftContract][listing.tokenId];

        emit NFTSold(listingId, msg.sender, listing.seller, totalPrice);
    }

    /**
     * @dev Cancel a listing
     * @param listingId ID of the listing
     */
    function cancelListing(uint256 listingId) external nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(msg.sender == listing.seller, "Not the seller");

        listing.active = false;
        delete nftToListing[listing.nftContract][listing.tokenId];

        emit ListingCancelled(listingId);
    }

    /**
     * @dev Make an offer on a listing
     * @param listingId ID of the listing
     * @param price Offer price
     * @param paymentToken Payment token address
     * @param duration Offer duration in seconds
     */
    function makeOffer(
        uint256 listingId,
        uint256 price,
        address paymentToken,
        uint256 duration
    ) external nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(price > 0, "Price must be greater than 0");
        require(msg.sender != listing.seller, "Cannot offer on your own NFT");

        uint256 offerId = offerCounter[listingId]++;

        offers[listingId][offerId] = Offer({
            buyer: msg.sender,
            price: price,
            paymentToken: paymentToken,
            expiresAt: block.timestamp + duration,
            active: true
        });

        emit OfferMade(listingId, offerId, msg.sender, price);
    }

    /**
     * @dev Accept an offer
     * @param listingId ID of the listing
     * @param offerId ID of the offer
     */
    function acceptOffer(uint256 listingId, uint256 offerId) external payable nonReentrant {
        Listing storage listing = listings[listingId];
        Offer storage offer = offers[listingId][offerId];

        require(listing.active, "Listing not active");
        require(offer.active, "Offer not active");
        require(msg.sender == listing.seller, "Not the seller");
        require(block.timestamp <= offer.expiresAt, "Offer expired");

        uint256 totalPrice = offer.price;
        uint256 fee = (totalPrice * feePercent) / 10000;
        uint256 sellerAmount = totalPrice - fee;

        if (offer.paymentToken == address(0)) {
            // ETH payment
            require(msg.value >= totalPrice, "Insufficient payment");

            payable(listing.seller).transfer(sellerAmount);

            if (msg.value > totalPrice) {
                payable(msg.sender).transfer(msg.value - totalPrice);
            }
        } else {
            // ERC20 payment
            IERC20 token = IERC20(offer.paymentToken);
            require(
                token.transferFrom(offer.buyer, listing.seller, sellerAmount),
                "Token transfer to seller failed"
            );
            require(
                token.transferFrom(offer.buyer, owner(), fee),
                "Token fee transfer failed"
            );
        }

        // Transfer NFT
        IERC721(listing.nftContract).safeTransferFrom(
            listing.seller,
            offer.buyer,
            listing.tokenId
        );

        listing.active = false;
        offer.active = false;
        delete nftToListing[listing.nftContract][listing.tokenId];

        emit OfferAccepted(listingId, offerId);
        emit NFTSold(listingId, offer.buyer, listing.seller, totalPrice);
    }

    /**
     * @dev Cancel an offer
     * @param listingId ID of the listing
     * @param offerId ID of the offer
     */
    function cancelOffer(uint256 listingId, uint256 offerId) external {
        Offer storage offer = offers[listingId][offerId];
        require(offer.active, "Offer not active");
        require(msg.sender == offer.buyer, "Not the buyer");

        offer.active = false;
        emit OfferCancelled(listingId, offerId);
    }

    /**
     * @dev Update marketplace fee (only owner)
     * @param newFee New fee in basis points
     */
    function setFeePercent(uint256 newFee) external onlyOwner {
        require(newFee <= MAX_FEE, "Fee too high");
        uint256 oldFee = feePercent;
        feePercent = newFee;
        emit FeeUpdated(oldFee, newFee);
    }

    /**
     * @dev Withdraw accumulated fees (only owner)
     */
    function withdrawFees() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to withdraw");
        payable(owner()).transfer(balance);
    }

    /**
     * @dev Get listing details
     * @param listingId ID of the listing
     */
    function getListing(uint256 listingId) external view returns (Listing memory) {
        return listings[listingId];
    }

    /**
     * @dev Get offer details
     * @param listingId ID of the listing
     * @param offerId ID of the offer
     */
    function getOffer(uint256 listingId, uint256 offerId) external view returns (Offer memory) {
        return offers[listingId][offerId];
    }
}
