/**
 * Cryptographic utilities for {{PROJECT_NAME}} Worker
 *
 * Author: {{AUTHOR}}
 */

/**
 * Generate a random UUID v4
 */
export function generateUUID(): string {
  return crypto.randomUUID();
}

/**
 * Generate random bytes as hex string
 */
export async function generateRandomHex(length: number): Promise<string> {
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");
}

/**
 * Hash a string using SHA-256
 */
export async function sha256(message: string): Promise<string> {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

/**
 * Hash a password using bcrypt-like approach
 * Note: For production, consider using a dedicated library
 */
export async function hashPassword(password: string): Promise<string> {
  const salt = await generateRandomHex(16);
  const hash = await sha256(password + salt);
  return `${salt}:${hash}`;
}

/**
 * Verify a password against a hash
 */
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  const [salt, expectedHash] = hash.split(":");
  if (!salt || !expectedHash) return false;
  const actualHash = await sha256(password + salt);
  return actualHash === expectedHash;
}

/**
 * Generate HMAC signature
 */
export async function generateHMAC(
  message: string,
  secret: string
): Promise<string> {
  const encoder = new TextEncoder();
  const keyData = encoder.encode(secret);
  const messageData = encoder.encode(message);

  const key = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );

  const signature = await crypto.subtle.sign("HMAC", key, messageData);
  const hashArray = Array.from(new Uint8Array(signature));
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

/**
 * Verify HMAC signature
 */
export async function verifyHMAC(
  message: string,
  signature: string,
  secret: string
): Promise<boolean> {
  const expectedSignature = await generateHMAC(message, secret);
  return signature === expectedSignature;
}

/**
 * Encode data to base64
 */
export function base64Encode(data: string): string {
  return btoa(data);
}

/**
 * Decode base64 data
 */
export function base64Decode(data: string): string {
  return atob(data);
}

/**
 * URL-safe base64 encode
 */
export function base64UrlEncode(data: string): string {
  return base64Encode(data)
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
}

/**
 * URL-safe base64 decode
 */
export function base64UrlDecode(data: string): string {
  let base64 = data.replace(/-/g, "+").replace(/_/g, "/");
  while (base64.length % 4) {
    base64 += "=";
  }
  return base64Decode(base64);
}

/**
 * Constant-time string comparison to prevent timing attacks
 */
export function timingSafeEqual(a: string, b: string): boolean {
  if (a.length !== b.length) {
    return false;
  }

  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }

  return result === 0;
}

/**
 * Generate a secure token
 */
export async function generateToken(length = 32): Promise<string> {
  return await generateRandomHex(length);
}

/**
 * Hash data for cache key
 */
export async function hashCacheKey(...parts: string[]): Promise<string> {
  const combined = parts.join(":");
  return await sha256(combined);
}
