/**
 * migrate.ts - Database migration script
 *
 * Author: {{AUTHOR}}
 *
 * Run with: deno run --allow-net --allow-env scripts/migrate.ts
 */

import { load } from "@std/dotenv";
import { Pool } from "postgres";

await load({ export: true });

const pool = new Pool(Deno.env.get("DATABASE_URL")!, 3, true);

const migrations = [
  {
    version: 1,
    name: "create_users_table",
    up: `
      CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        email VARCHAR(255) UNIQUE NOT NULL,
        name VARCHAR(255),
        password_hash TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );

      CREATE INDEX idx_users_email ON users(email);
    `,
    down: `DROP TABLE IF EXISTS users;`,
  },
  {
    version: 2,
    name: "create_items_table",
    up: `
      CREATE TABLE IF NOT EXISTS items (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        description TEXT,
        status VARCHAR(50) DEFAULT 'active',
        user_id UUID REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );

      CREATE INDEX idx_items_user_id ON items(user_id);
      CREATE INDEX idx_items_status ON items(status);
    `,
    down: `DROP TABLE IF EXISTS items;`,
  },
];

async function createMigrationsTable() {
  const client = await pool.connect();
  try {
    await client.queryObject(`
      CREATE TABLE IF NOT EXISTS migrations (
        version INTEGER PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        applied_at TIMESTAMP DEFAULT NOW()
      );
    `);
  } finally {
    client.release();
  }
}

async function getAppliedMigrations(): Promise<number[]> {
  const client = await pool.connect();
  try {
    const result = await client.queryObject<{ version: number }>(
      "SELECT version FROM migrations ORDER BY version",
    );
    return result.rows.map((row) => row.version);
  } finally {
    client.release();
  }
}

async function applyMigration(version: number, name: string, sql: string) {
  const client = await pool.connect();
  try {
    await client.queryObject("BEGIN");
    await client.queryObject(sql);
    await client.queryObject(
      "INSERT INTO migrations (version, name) VALUES ($1, $2)",
      [version, name],
    );
    await client.queryObject("COMMIT");
    console.log(`‚úÖ Applied migration ${version}: ${name}`);
  } catch (error) {
    await client.queryObject("ROLLBACK");
    console.error(`‚ùå Failed to apply migration ${version}: ${name}`);
    throw error;
  } finally {
    client.release();
  }
}

async function migrate() {
  console.log("üöÄ Starting database migrations...\n");

  await createMigrationsTable();
  const applied = await getAppliedMigrations();

  for (const migration of migrations) {
    if (!applied.includes(migration.version)) {
      await applyMigration(migration.version, migration.name, migration.up);
    } else {
      console.log(`‚è≠Ô∏è  Skipping migration ${migration.version}: ${migration.name} (already applied)`);
    }
  }

  console.log("\n‚úÖ All migrations completed");
  await pool.end();
}

if (import.meta.main) {
  await migrate();
}
