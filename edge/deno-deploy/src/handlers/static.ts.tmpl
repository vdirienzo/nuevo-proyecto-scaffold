/**
 * static.ts - Static file serving handler
 *
 * Author: {{AUTHOR}}
 */

import type { Context } from "oak";
import { join } from "@std/path";

const STATIC_DIR = "./static";
const MIME_TYPES: Record<string, string> = {
  ".html": "text/html",
  ".css": "text/css",
  ".js": "application/javascript",
  ".json": "application/json",
  ".png": "image/png",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".gif": "image/gif",
  ".svg": "image/svg+xml",
  ".ico": "image/x-icon",
  ".woff": "font/woff",
  ".woff2": "font/woff2",
  ".ttf": "font/ttf",
  ".txt": "text/plain",
};

export async function serveStatic(ctx: Context) {
  try {
    const path = ctx.params.path || "";
    const filePath = join(STATIC_DIR, path);

    // Security check: prevent directory traversal
    const realPath = await Deno.realPath(filePath).catch(() => null);
    const realStaticDir = await Deno.realPath(STATIC_DIR);

    if (!realPath || !realPath.startsWith(realStaticDir)) {
      ctx.response.status = 403;
      ctx.response.body = { error: "Forbidden" };
      return;
    }

    // Read file
    const file = await Deno.readFile(realPath);

    // Set content type
    const ext = path.substring(path.lastIndexOf("."));
    const contentType = MIME_TYPES[ext] || "application/octet-stream";

    ctx.response.headers.set("Content-Type", contentType);
    ctx.response.headers.set("Cache-Control", "public, max-age=3600");
    ctx.response.body = file;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      ctx.response.status = 404;
      ctx.response.body = { error: "File not found" };
    } else {
      ctx.response.status = 500;
      ctx.response.body = { error: "Internal server error" };
    }
  }
}
