/**
 * auth.ts - JWT authentication middleware
 *
 * Author: {{AUTHOR}}
 */

import type { Context, Next } from "oak";
import { verify } from "djwt";
import { crypto } from "@std/crypto";

const JWT_SECRET = Deno.env.get("JWT_SECRET") || "change-me-in-production";
const JWT_KEY = await crypto.subtle.importKey(
  "raw",
  new TextEncoder().encode(JWT_SECRET),
  { name: "HMAC", hash: "SHA-256" },
  false,
  ["sign", "verify"],
);

export async function authMiddleware(ctx: Context, next: Next) {
  const authHeader = ctx.request.headers.get("Authorization");

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    ctx.response.status = 401;
    ctx.response.body = { error: "Missing or invalid authorization header" };
    return;
  }

  try {
    const token = authHeader.substring(7);
    const payload = await verify(token, JWT_KEY);

    if (!payload.sub) {
      ctx.response.status = 401;
      ctx.response.body = { error: "Invalid token payload" };
      return;
    }

    // Attach user info to context state
    ctx.state.userId = payload.sub;
    ctx.state.email = payload.email;

    await next();
  } catch (error) {
    ctx.response.status = 401;
    ctx.response.body = { error: "Invalid or expired token" };
  }
}

/**
 * Optional auth middleware - continues even without valid token
 */
export async function optionalAuthMiddleware(ctx: Context, next: Next) {
  const authHeader = ctx.request.headers.get("Authorization");

  if (authHeader && authHeader.startsWith("Bearer ")) {
    try {
      const token = authHeader.substring(7);
      const payload = await verify(token, JWT_KEY);

      if (payload.sub) {
        ctx.state.userId = payload.sub;
        ctx.state.email = payload.email;
      }
    } catch {
      // Ignore invalid tokens for optional auth
    }
  }

  await next();
}
