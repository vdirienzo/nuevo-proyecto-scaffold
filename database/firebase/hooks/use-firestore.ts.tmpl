// use-firestore.ts - Firestore real-time hooks
// Author: {{AUTHOR}}
// Project: {{PROJECT_NAME}}

import { useState, useEffect, useCallback } from 'react';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  query,
  type DocumentData,
  type QueryConstraint,
  type DocumentSnapshot,
  type QuerySnapshot,
  type Unsubscribe,
  type WithFieldValue,
  type UpdateData,
  type PartialWithFieldValue,
} from 'firebase/firestore';
import { db } from '../firebase-config';

interface DataState<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

interface CollectionState<T> {
  data: T[];
  loading: boolean;
  error: Error | null;
}

// Hook for real-time single document
export function useDocument<T = DocumentData>(
  collectionName: string,
  docId: string | null
): DataState<T> {
  const [state, setState] = useState<DataState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    if (!docId) {
      setState({ data: null, loading: false, error: null });
      return;
    }

    const docRef = doc(db, collectionName, docId);

    const unsubscribe: Unsubscribe = onSnapshot(
      docRef,
      (snapshot: DocumentSnapshot<DocumentData>) => {
        if (snapshot.exists()) {
          setState({
            data: { id: snapshot.id, ...snapshot.data() } as T,
            loading: false,
            error: null,
          });
        } else {
          setState({
            data: null,
            loading: false,
            error: new Error('Document not found'),
          });
        }
      },
      (error) => {
        setState({
          data: null,
          loading: false,
          error: error as Error,
        });
      }
    );

    return () => unsubscribe();
  }, [collectionName, docId]);

  return state;
}

// Hook for real-time collection with query constraints
export function useCollection<T = DocumentData>(
  collectionName: string,
  queryConstraints: QueryConstraint[] = []
): CollectionState<T> {
  const [state, setState] = useState<CollectionState<T>>({
    data: [],
    loading: true,
    error: null,
  });

  useEffect(() => {
    const collectionRef = collection(db, collectionName);
    const q = query(collectionRef, ...queryConstraints);

    const unsubscribe: Unsubscribe = onSnapshot(
      q,
      (snapshot: QuerySnapshot<DocumentData>) => {
        const items = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as T[];

        setState({
          data: items,
          loading: false,
          error: null,
        });
      },
      (error) => {
        setState({
          data: [],
          loading: false,
          error: error as Error,
        });
      }
    );

    return () => unsubscribe();
  }, [collectionName, queryConstraints]);

  return state;
}

// Hook for adding documents (mutation)
export function useAddDocument<T = DocumentData>(collectionName: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const addDocument = useCallback(
    async (data: WithFieldValue<T>) => {
      try {
        setLoading(true);
        setError(null);
        const collectionRef = collection(db, collectionName);
        const docRef = await addDoc(collectionRef, data as DocumentData);
        setLoading(false);
        return docRef.id;
      } catch (err) {
        const error = err as Error;
        setError(error);
        setLoading(false);
        throw error;
      }
    },
    [collectionName]
  );

  return { addDocument, loading, error };
}

// Hook for updating documents (mutation)
export function useUpdateDocument<T = DocumentData>(collectionName: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const updateDocument = useCallback(
    async (docId: string, data: UpdateData<T>) => {
      try {
        setLoading(true);
        setError(null);
        const docRef = doc(db, collectionName, docId);
        await updateDoc(docRef, data as UpdateData<DocumentData>);
        setLoading(false);
      } catch (err) {
        const error = err as Error;
        setError(error);
        setLoading(false);
        throw error;
      }
    },
    [collectionName]
  );

  return { updateDocument, loading, error };
}

// Hook for deleting documents (mutation)
export function useDeleteDocument(collectionName: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const deleteDocument = useCallback(
    async (docId: string) => {
      try {
        setLoading(true);
        setError(null);
        const docRef = doc(db, collectionName, docId);
        await deleteDoc(docRef);
        setLoading(false);
      } catch (err) {
        const error = err as Error;
        setError(error);
        setLoading(false);
        throw error;
      }
    },
    [collectionName]
  );

  return { deleteDocument, loading, error };
}

// Hook for optimistic updates
export function useOptimisticUpdate<T = DocumentData>(
  collectionName: string,
  docId: string | null
) {
  const [optimisticData, setOptimisticData] = useState<T | null>(null);
  const documentState = useDocument<T>(collectionName, docId);

  const updateOptimistic = useCallback(
    async (
      updates: PartialWithFieldValue<T>,
      rollbackOnError: boolean = true
    ) => {
      if (!docId) {
        throw new Error('Document ID is required for optimistic updates');
      }

      // Store current data for potential rollback
      const previousData = documentState.data;

      try {
        // Apply optimistic update immediately
        setOptimisticData((prev) => ({
          ...(prev || documentState.data),
          ...updates,
        } as T));

        // Perform actual update
        const docRef = doc(db, collectionName, docId);
        await updateDoc(docRef, updates as UpdateData<DocumentData>);

        // Clear optimistic data (real data will come from onSnapshot)
        setOptimisticData(null);
      } catch (error) {
        // Rollback on error if requested
        if (rollbackOnError) {
          setOptimisticData(previousData);
        }
        throw error;
      }
    },
    [collectionName, docId, documentState.data]
  );

  return {
    data: optimisticData || documentState.data,
    loading: documentState.loading,
    error: documentState.error,
    updateOptimistic,
  };
}

// Hook for fetching a single document once (non-realtime)
export function useFetchDocument<T = DocumentData>(
  collectionName: string,
  docId: string | null
) {
  const [state, setState] = useState<DataState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    if (!docId) {
      setState({ data: null, loading: false, error: null });
      return;
    }

    const fetchDocument = async () => {
      try {
        setState((prev) => ({ ...prev, loading: true, error: null }));
        const docRef = doc(db, collectionName, docId);
        const snapshot = await getDoc(docRef);

        if (snapshot.exists()) {
          setState({
            data: { id: snapshot.id, ...snapshot.data() } as T,
            loading: false,
            error: null,
          });
        } else {
          setState({
            data: null,
            loading: false,
            error: new Error('Document not found'),
          });
        }
      } catch (err) {
        setState({
          data: null,
          loading: false,
          error: err as Error,
        });
      }
    };

    fetchDocument();
  }, [collectionName, docId]);

  return state;
}

// Hook for fetching a collection once (non-realtime)
export function useFetchCollection<T = DocumentData>(
  collectionName: string,
  queryConstraints: QueryConstraint[] = []
) {
  const [state, setState] = useState<CollectionState<T>>({
    data: [],
    loading: true,
    error: null,
  });

  useEffect(() => {
    const fetchCollection = async () => {
      try {
        setState((prev) => ({ ...prev, loading: true, error: null }));
        const collectionRef = collection(db, collectionName);
        const q = query(collectionRef, ...queryConstraints);
        const snapshot = await getDocs(q);

        const items = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as T[];

        setState({
          data: items,
          loading: false,
          error: null,
        });
      } catch (err) {
        setState({
          data: [],
          loading: false,
          error: err as Error,
        });
      }
    };

    fetchCollection();
  }, [collectionName, queryConstraints]);

  return state;
}
