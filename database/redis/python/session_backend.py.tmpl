"""
Session Backend for FastAPI

Author: {{AUTHOR}}
Project: {{PROJECT_NAME}}
"""

import json
from typing import Optional, Any, Dict
from datetime import datetime, timedelta
from uuid import uuid4

from redis.asyncio import Redis
from loguru import logger

from .redis_client import get_redis, RedisKeys, RedisTTL


class SessionData:
    """Session data structure."""

    def __init__(
        self,
        user_id: str,
        email: Optional[str] = None,
        roles: Optional[list[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        created_at: Optional[datetime] = None,
        last_accessed_at: Optional[datetime] = None,
    ):
        self.user_id = user_id
        self.email = email
        self.roles = roles or []
        self.metadata = metadata or {}
        self.created_at = created_at or datetime.now()
        self.last_accessed_at = last_accessed_at or datetime.now()

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "user_id": self.user_id,
            "email": self.email,
            "roles": self.roles,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
            "last_accessed_at": self.last_accessed_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict) -> "SessionData":
        """Create from dictionary."""
        return cls(
            user_id=data["user_id"],
            email=data.get("email"),
            roles=data.get("roles", []),
            metadata=data.get("metadata", {}),
            created_at=datetime.fromisoformat(data["created_at"]),
            last_accessed_at=datetime.fromisoformat(data["last_accessed_at"]),
        )


class SessionBackend:
    """Redis session backend."""

    def __init__(
        self,
        redis: Redis,
        prefix: str = RedisKeys.SESSION,
        ttl: int = RedisTTL.VERY_LONG,
    ):
        self.redis = redis
        self.prefix = prefix
        self.ttl = ttl

    def _build_key(self, session_id: str) -> str:
        """Build session key."""
        return f"{self.prefix}{session_id}"

    async def create(
        self,
        user_id: str,
        email: Optional[str] = None,
        roles: Optional[list[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Create new session."""
        session_id = str(uuid4())
        session_data = SessionData(
            user_id=user_id,
            email=email,
            roles=roles,
            metadata=metadata,
        )

        key = self._build_key(session_id)
        await self.redis.setex(key, self.ttl, json.dumps(session_data.to_dict()))

        logger.debug(f"Session created: {session_id}")
        return session_id

    async def get(self, session_id: str) -> Optional[SessionData]:
        """Get session data."""
        try:
            key = self._build_key(session_id)
            data = await self.redis.get(key)

            if not data:
                return None

            session_data = SessionData.from_dict(json.loads(data))

            # Update last accessed time
            session_data.last_accessed_at = datetime.now()
            await self.redis.setex(key, self.ttl, json.dumps(session_data.to_dict()))

            return session_data
        except Exception as e:
            logger.error(f"Session get error: {e}")
            return None

    async def update(self, session_id: str, updates: Dict[str, Any]) -> bool:
        """Update session data."""
        try:
            existing = await self.get(session_id)

            if not existing:
                return False

            # Update fields
            for key, value in updates.items():
                if hasattr(existing, key):
                    setattr(existing, key, value)

            existing.last_accessed_at = datetime.now()

            key = self._build_key(session_id)
            await self.redis.setex(key, self.ttl, json.dumps(existing.to_dict()))

            logger.debug(f"Session updated: {session_id}")
            return True
        except Exception as e:
            logger.error(f"Session update error: {e}")
            return False

    async def destroy(self, session_id: str) -> bool:
        """Destroy session."""
        try:
            key = self._build_key(session_id)
            result = await self.redis.delete(key)

            if result > 0:
                logger.debug(f"Session destroyed: {session_id}")
                return True

            return False
        except Exception as e:
            logger.error(f"Session destroy error: {e}")
            return False

    async def destroy_user_sessions(self, user_id: str) -> int:
        """Destroy all sessions for a user."""
        try:
            pattern = f"{self.prefix}*"
            deleted = 0

            async for key in self.redis.scan_iter(match=pattern):
                data = await self.redis.get(key)
                if data:
                    session = SessionData.from_dict(json.loads(data))
                    if session.user_id == user_id:
                        await self.redis.delete(key)
                        deleted += 1

            logger.debug(f"Destroyed {deleted} sessions for user {user_id}")
            return deleted
        except Exception as e:
            logger.error(f"Destroy user sessions error: {e}")
            return 0

    async def touch(self, session_id: str) -> bool:
        """Extend session TTL."""
        try:
            key = self._build_key(session_id)
            result = await self.redis.expire(key, self.ttl)
            return result == 1
        except Exception as e:
            logger.error(f"Session touch error: {e}")
            return False

    async def get_user_sessions(self, user_id: str) -> list[SessionData]:
        """Get all active sessions for a user."""
        try:
            pattern = f"{self.prefix}*"
            sessions = []

            async for key in self.redis.scan_iter(match=pattern):
                data = await self.redis.get(key)
                if data:
                    session = SessionData.from_dict(json.loads(data))
                    if session.user_id == user_id:
                        sessions.append(session)

            return sessions
        except Exception as e:
            logger.error(f"Get user sessions error: {e}")
            return []


# FastAPI middleware
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware


class SessionMiddleware(BaseHTTPMiddleware):
    """Session middleware for FastAPI."""

    def __init__(
        self,
        app,
        cookie_name: str = "session_id",
        cookie_max_age: int = 7 * 24 * 60 * 60,  # 7 days
        cookie_secure: bool = False,
        cookie_httponly: bool = True,
        cookie_samesite: str = "lax",
    ):
        super().__init__(app)
        self.cookie_name = cookie_name
        self.cookie_max_age = cookie_max_age
        self.cookie_secure = cookie_secure
        self.cookie_httponly = cookie_httponly
        self.cookie_samesite = cookie_samesite

    async def dispatch(self, request: Request, call_next):
        """Process request."""
        # Get session ID from cookie
        session_id = request.cookies.get(self.cookie_name)

        if session_id:
            # Load session data
            redis = await get_redis()
            backend = SessionBackend(redis)
            session_data = await backend.get(session_id)

            if session_data:
                request.state.session = session_data
                request.state.session_id = session_id

        # Process request
        response = await call_next(request)

        # Set session cookie if needed
        if not session_id and hasattr(request.state, "session_id"):
            response.set_cookie(
                key=self.cookie_name,
                value=request.state.session_id,
                max_age=self.cookie_max_age,
                secure=self.cookie_secure,
                httponly=self.cookie_httponly,
                samesite=self.cookie_samesite,
            )

        return response


# Example usage:
# from fastapi import FastAPI, Depends, HTTPException
#
# app = FastAPI()
# app.add_middleware(SessionMiddleware)
#
# async def get_current_session(request: Request) -> SessionData:
#     if not hasattr(request.state, "session"):
#         raise HTTPException(status_code=401, detail="Not authenticated")
#     return request.state.session
#
# @app.get("/profile")
# async def profile(session: SessionData = Depends(get_current_session)):
#     return {"user_id": session.user_id, "email": session.email}
