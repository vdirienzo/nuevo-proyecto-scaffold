/**
 * Session Middleware for Express
 *
 * Author: {{AUTHOR}}
 * Project: {{PROJECT_NAME}}
 */

import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { sessionStore, SessionData } from './session.store';
import { logger } from '@/lib/logger';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      sessionId?: string;
      session?: SessionData;
    }
  }
}

export interface SessionMiddlewareOptions {
  cookieName?: string;
  cookieMaxAge?: number;
  cookieSecure?: boolean;
  cookieHttpOnly?: boolean;
  cookieSameSite?: 'strict' | 'lax' | 'none';
  autoExtend?: boolean;
}

export function sessionMiddleware(options: SessionMiddlewareOptions = {}) {
  const {
    cookieName = 'sessionId',
    cookieMaxAge = 7 * 24 * 60 * 60 * 1000, // 7 days
    cookieSecure = process.env.NODE_ENV === 'production',
    cookieHttpOnly = true,
    cookieSameSite = 'lax',
    autoExtend = true,
  } = options;

  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      // Get session ID from cookie
      let sessionId = req.cookies?.[cookieName];

      // If no session ID, create new one
      if (!sessionId) {
        sessionId = uuidv4();

        // Set cookie
        res.cookie(cookieName, sessionId, {
          maxAge: cookieMaxAge,
          secure: cookieSecure,
          httpOnly: cookieHttpOnly,
          sameSite: cookieSameSite,
        });

        logger.debug(`New session created: ${sessionId}`);
      }

      // Attach session ID to request
      req.sessionId = sessionId;

      // Try to load session data
      const sessionData = await sessionStore.get(sessionId);

      if (sessionData) {
        req.session = sessionData;

        // Auto-extend session
        if (autoExtend) {
          await sessionStore.touch(sessionId);
        }

        logger.debug(`Session loaded: ${sessionId}`);
      } else {
        logger.debug(`No session data found for: ${sessionId}`);
      }

      // Add helper methods to response
      res.locals.createSession = async (data: Omit<SessionData, 'createdAt' | 'lastAccessedAt'>) => {
        await sessionStore.create(sessionId!, data);
        req.session = await sessionStore.get(sessionId!);
      };

      res.locals.updateSession = async (updates: Partial<SessionData>) => {
        await sessionStore.update(sessionId!, updates);
        req.session = await sessionStore.get(sessionId!);
      };

      res.locals.destroySession = async () => {
        await sessionStore.destroy(sessionId!);
        req.session = undefined;
        res.clearCookie(cookieName);
      };

      next();
    } catch (error) {
      logger.error('Session middleware error:', error);
      next(error);
    }
  };
}

/**
 * Require authenticated session middleware
 */
export function requireSession(req: Request, res: Response, next: NextFunction) {
  if (!req.session || !req.session.userId) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required',
    });
  }

  next();
}

/**
 * Require specific roles middleware
 */
export function requireRoles(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.session || !req.session.userId) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required',
      });
    }

    const userRoles = req.session.roles || [];
    const hasRequiredRole = roles.some((role) => userRoles.includes(role));

    if (!hasRequiredRole) {
      return res.status(403).json({
        success: false,
        error: 'Insufficient permissions',
      });
    }

    next();
  };
}
