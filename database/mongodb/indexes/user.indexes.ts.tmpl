/**
 * user.indexes.ts - MongoDB index definitions for User collection
 *
 * Author: {{AUTHOR}}
 * Project: {{PROJECT_NAME}}
 */

import { User } from '../schemas/user.schema';
import { logger } from '../utils/logger';

export async function createUserIndexes(): Promise<void> {
  try {
    logger.info('Creating User collection indexes...');

    // Single field indexes
    await User.collection.createIndex({ email: 1 }, { unique: true, name: 'idx_email' });
    await User.collection.createIndex({ username: 1 }, { unique: true, name: 'idx_username' });
    await User.collection.createIndex({ role: 1 }, { name: 'idx_role' });
    await User.collection.createIndex({ isActive: 1 }, { name: 'idx_is_active' });
    await User.collection.createIndex({ isEmailVerified: 1 }, { name: 'idx_is_email_verified' });
    await User.collection.createIndex({ createdAt: -1 }, { name: 'idx_created_at' });
    await User.collection.createIndex({ lastLoginAt: -1 }, { name: 'idx_last_login_at' });

    // Compound indexes for common queries
    await User.collection.createIndex(
      { isActive: 1, role: 1 },
      { name: 'idx_active_role' }
    );

    await User.collection.createIndex(
      { isEmailVerified: 1, isActive: 1 },
      { name: 'idx_verified_active' }
    );

    // Text index for search
    await User.collection.createIndex(
      { username: 'text', email: 'text', firstName: 'text', lastName: 'text' },
      { name: 'idx_text_search' }
    );

    // Sparse indexes for optional fields
    await User.collection.createIndex(
      { passwordResetToken: 1 },
      { sparse: true, name: 'idx_password_reset_token' }
    );

    await User.collection.createIndex(
      { emailVerificationToken: 1 },
      { sparse: true, name: 'idx_email_verification_token' }
    );

    // TTL index for automatic deletion of unverified accounts after 30 days
    await User.collection.createIndex(
      { createdAt: 1 },
      {
        expireAfterSeconds: 30 * 24 * 60 * 60, // 30 days
        partialFilterExpression: { isEmailVerified: false },
        name: 'idx_ttl_unverified',
      }
    );

    logger.info('User collection indexes created successfully');
  } catch (error) {
    logger.error('Failed to create User collection indexes:', error);
    throw error;
  }
}

export async function dropUserIndexes(): Promise<void> {
  try {
    logger.info('Dropping User collection indexes...');
    await User.collection.dropIndexes();
    logger.info('User collection indexes dropped successfully');
  } catch (error) {
    logger.error('Failed to drop User collection indexes:', error);
    throw error;
  }
}

export async function listUserIndexes(): Promise<any[]> {
  try {
    const indexes = await User.collection.listIndexes().toArray();
    logger.info('User collection indexes:', indexes);
    return indexes;
  } catch (error) {
    logger.error('Failed to list User collection indexes:', error);
    throw error;
  }
}

/**
 * Index performance recommendations:
 *
 * 1. Most selective fields first in compound indexes
 * 2. Equality filters before range filters
 * 3. Sort fields last in compound indexes
 * 4. Use covered queries when possible
 * 5. Monitor index usage with explain()
 * 6. Remove unused indexes
 *
 * Common query patterns for User:
 * - Find by email (unique lookup) → idx_email
 * - Find by username (unique lookup) → idx_username
 * - Find active users by role → idx_active_role
 * - Find verified and active users → idx_verified_active
 * - Search users by name/email → idx_text_search
 * - Recent registrations → idx_created_at
 * - Recent logins → idx_last_login_at
 */
