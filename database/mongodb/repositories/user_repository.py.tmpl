#!/usr/bin/env python3
"""
user_repository.py - User repository for async operations

Author: {{AUTHOR}}
Project: {{PROJECT_NAME}}

Dependencies: beanie, motor
"""

from typing import Optional
from datetime import datetime

from ..models.user import User


class UserRepository:
    """Repository for User operations."""

    @staticmethod
    async def create(
        email: str,
        username: str,
        password: str,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        role: str = 'user',
    ) -> User:
        """Create new user."""
        user = User(
            email=email.lower(),
            username=username.lower(),
            first_name=first_name,
            last_name=last_name,
            role=role,
        )
        user.set_password(password)
        await user.insert()
        return user

    @staticmethod
    async def find_by_id(user_id: str) -> Optional[User]:
        """Find user by ID."""
        return await User.get(user_id)

    @staticmethod
    async def find_by_email(email: str) -> Optional[User]:
        """Find user by email."""
        return await User.find_by_email(email)

    @staticmethod
    async def find_by_username(username: str) -> Optional[User]:
        """Find user by username."""
        return await User.find_by_username(username)

    @staticmethod
    async def find_all(skip: int = 0, limit: int = 100) -> list[User]:
        """Find all users with pagination."""
        return await User.find_all().skip(skip).limit(limit).to_list()

    @staticmethod
    async def find_active_users() -> list[User]:
        """Find all active users."""
        return await User.find_active_users()

    @staticmethod
    async def find_by_role(role: str) -> list[User]:
        """Find users by role."""
        return await User.find_by_role(role)

    @staticmethod
    async def update(user_id: str, **kwargs) -> Optional[User]:
        """Update user."""
        user = await User.get(user_id)
        if not user:
            return None

        for key, value in kwargs.items():
            if hasattr(user, key):
                setattr(user, key, value)

        user.updated_at = datetime.utcnow()
        await user.save()
        return user

    @staticmethod
    async def update_password(user_id: str, new_password: str) -> Optional[User]:
        """Update user password."""
        user = await User.get(user_id)
        if not user:
            return None

        user.set_password(new_password)
        await user.save()
        return user

    @staticmethod
    async def delete(user_id: str, soft: bool = True) -> bool:
        """Delete user (soft or hard)."""
        user = await User.get(user_id)
        if not user:
            return False

        if soft:
            await user.soft_delete()
        else:
            await user.delete()

        return True

    @staticmethod
    async def restore(user_id: str) -> Optional[User]:
        """Restore soft-deleted user."""
        user = await User.get(user_id)
        if not user:
            return None

        await user.restore()
        return user

    @staticmethod
    async def activate(user_id: str) -> Optional[User]:
        """Activate user."""
        return await UserRepository.update(user_id, is_active=True)

    @staticmethod
    async def deactivate(user_id: str) -> Optional[User]:
        """Deactivate user."""
        return await UserRepository.update(user_id, is_active=False)

    @staticmethod
    async def verify_email(user_id: str) -> Optional[User]:
        """Verify user email."""
        user = await User.get(user_id)
        if not user:
            return None

        await user.verify_email()
        return user

    @staticmethod
    async def update_last_login(user_id: str) -> Optional[User]:
        """Update last login timestamp."""
        user = await User.get(user_id)
        if not user:
            return None

        await user.update_last_login()
        return user

    @staticmethod
    async def search(search_term: str, limit: int = 10) -> list[User]:
        """Search users."""
        return await User.search_users(search_term, limit)

    @staticmethod
    async def count_all() -> int:
        """Count all users."""
        return await User.count()

    @staticmethod
    async def count_active() -> int:
        """Count active users."""
        return await User.find(User.is_active == True).count()

    @staticmethod
    async def count_by_role(role: str) -> int:
        """Count users by role."""
        return await User.find(User.role == role).count()

    @staticmethod
    async def get_stats() -> dict:
        """Get user statistics."""
        total = await UserRepository.count_all()
        active = await UserRepository.count_active()
        verified = await User.find(User.is_email_verified == True).count()

        by_role = {
            'user': await UserRepository.count_by_role('user'),
            'admin': await UserRepository.count_by_role('admin'),
            'moderator': await UserRepository.count_by_role('moderator'),
        }

        return {
            'total': total,
            'active': active,
            'verified': verified,
            'by_role': by_role,
        }

    @staticmethod
    async def exists_by_email(email: str) -> bool:
        """Check if user exists by email."""
        user = await User.find_by_email(email)
        return user is not None

    @staticmethod
    async def exists_by_username(username: str) -> bool:
        """Check if user exists by username."""
        user = await User.find_by_username(username)
        return user is not None


# Singleton instance
user_repository = UserRepository()
