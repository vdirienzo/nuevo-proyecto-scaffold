/*!
 * SQLite Database Layer
 *
 * Author: {{AUTHOR}}
 */

use crate::error::{AppError, AppResult};
use serde::{Deserialize, Serialize};
use sqlx::sqlite::{SqlitePool, SqlitePoolOptions};
use sqlx::FromRow;
use std::path::Path;
use tracing::{info, warn};

/// Database connection wrapper
pub struct Database {
    pool: SqlitePool,
}

impl Database {
    /// Create new database connection
    ///
    /// # Arguments
    /// * `path` - Path to SQLite database file (uses in-memory if None)
    /// * `max_connections` - Maximum number of connections in pool
    pub async fn new(path: Option<&Path>, max_connections: u32) -> AppResult<Self> {
        let database_url = if let Some(path) = path {
            // Ensure parent directory exists
            if let Some(parent) = path.parent() {
                tokio::fs::create_dir_all(parent).await?;
            }

            format!("sqlite:{}?mode=rwc", path.display())
        } else {
            warn!("Using in-memory database - data will not persist");
            "sqlite::memory:".to_string()
        };

        info!("Connecting to database: {}", database_url);

        let pool = SqlitePoolOptions::new()
            .max_connections(max_connections)
            .connect(&database_url)
            .await?;

        let db = Self { pool };

        // Run migrations
        db.run_migrations().await?;

        Ok(db)
    }

    /// Run database migrations
    async fn run_migrations(&self) -> AppResult<()> {
        info!("Running database migrations");

        // Enable foreign keys
        sqlx::query("PRAGMA foreign_keys = ON")
            .execute(&self.pool)
            .await?;

        // Create users table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                email TEXT NOT NULL UNIQUE,
                password_hash TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            )
            "#
        )
        .execute(&self.pool)
        .await?;

        // Create settings table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at INTEGER NOT NULL
            )
            "#
        )
        .execute(&self.pool)
        .await?;

        // Create sessions table (for tracking active sessions)
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                created_at INTEGER NOT NULL,
                expires_at INTEGER NOT NULL,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            )
            "#
        )
        .execute(&self.pool)
        .await?;

        // Create indexes
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id)")
            .execute(&self.pool)
            .await?;

        sqlx::query("CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token)")
            .execute(&self.pool)
            .await?;

        info!("Database migrations completed");
        Ok(())
    }

    /// Perform health check on database
    pub async fn health_check(&self) -> AppResult<()> {
        sqlx::query("SELECT 1")
            .execute(&self.pool)
            .await?;
        Ok(())
    }

    // ==================== User Operations ====================

    /// Create a new user
    pub async fn create_user(&self, user: CreateUser) -> AppResult<User> {
        let now = chrono::Utc::now().timestamp();

        let result = sqlx::query(
            r#"
            INSERT INTO users (username, email, password_hash, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?)
            "#
        )
        .bind(&user.username)
        .bind(&user.email)
        .bind(&user.password_hash)
        .bind(now)
        .bind(now)
        .execute(&self.pool)
        .await?;

        let id = result.last_insert_rowid();
        self.get_user_by_id(id).await?
            .ok_or_else(|| AppError::Internal("Failed to retrieve created user".to_string()))
    }

    /// Get user by ID
    pub async fn get_user_by_id(&self, id: i64) -> AppResult<Option<User>> {
        let user = sqlx::query_as::<_, User>(
            "SELECT id, username, email, password_hash, created_at, updated_at FROM users WHERE id = ?"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }

    /// Get user by username
    pub async fn get_user_by_username(&self, username: &str) -> AppResult<Option<User>> {
        let user = sqlx::query_as::<_, User>(
            "SELECT id, username, email, password_hash, created_at, updated_at FROM users WHERE username = ?"
        )
        .bind(username)
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }

    /// Get user by email
    pub async fn get_user_by_email(&self, email: &str) -> AppResult<Option<User>> {
        let user = sqlx::query_as::<_, User>(
            "SELECT id, username, email, password_hash, created_at, updated_at FROM users WHERE email = ?"
        )
        .bind(email)
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }

    /// Update user
    pub async fn update_user(&self, id: i64, update: UpdateUser) -> AppResult<User> {
        let now = chrono::Utc::now().timestamp();

        sqlx::query(
            r#"
            UPDATE users
            SET email = COALESCE(?, email),
                password_hash = COALESCE(?, password_hash),
                updated_at = ?
            WHERE id = ?
            "#
        )
        .bind(update.email)
        .bind(update.password_hash)
        .bind(now)
        .bind(id)
        .execute(&self.pool)
        .await?;

        self.get_user_by_id(id).await?
            .ok_or_else(|| AppError::NotFound(format!("User {}", id)))
    }

    /// Delete user
    pub async fn delete_user(&self, id: i64) -> AppResult<()> {
        sqlx::query("DELETE FROM users WHERE id = ?")
            .bind(id)
            .execute(&self.pool)
            .await?;

        Ok(())
    }

    /// List all users
    pub async fn list_users(&self) -> AppResult<Vec<User>> {
        let users = sqlx::query_as::<_, User>(
            "SELECT id, username, email, password_hash, created_at, updated_at FROM users ORDER BY created_at DESC"
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(users)
    }

    // ==================== Settings Operations ====================

    /// Get setting by key
    pub async fn get_setting(&self, key: &str) -> AppResult<Option<String>> {
        let result = sqlx::query_as::<_, (String,)>(
            "SELECT value FROM settings WHERE key = ?"
        )
        .bind(key)
        .fetch_optional(&self.pool)
        .await?;

        Ok(result.map(|r| r.0))
    }

    /// Set setting
    pub async fn set_setting(&self, key: &str, value: &str) -> AppResult<()> {
        let now = chrono::Utc::now().timestamp();

        sqlx::query(
            r#"
            INSERT INTO settings (key, value, updated_at)
            VALUES (?, ?, ?)
            ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = excluded.updated_at
            "#
        )
        .bind(key)
        .bind(value)
        .bind(now)
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    /// Delete setting
    pub async fn delete_setting(&self, key: &str) -> AppResult<()> {
        sqlx::query("DELETE FROM settings WHERE key = ?")
            .bind(key)
            .execute(&self.pool)
            .await?;

        Ok(())
    }

    /// Get all settings
    pub async fn get_all_settings(&self) -> AppResult<Vec<Setting>> {
        let settings = sqlx::query_as::<_, Setting>(
            "SELECT key, value, updated_at FROM settings ORDER BY key"
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(settings)
    }

    // ==================== Session Operations ====================

    /// Create session
    pub async fn create_session(&self, user_id: i64, token: &str, expires_in_secs: i64) -> AppResult<Session> {
        let now = chrono::Utc::now().timestamp();
        let expires_at = now + expires_in_secs;

        let result = sqlx::query(
            r#"
            INSERT INTO sessions (user_id, token, created_at, expires_at)
            VALUES (?, ?, ?, ?)
            "#
        )
        .bind(user_id)
        .bind(token)
        .bind(now)
        .bind(expires_at)
        .execute(&self.pool)
        .await?;

        let id = result.last_insert_rowid();

        Ok(Session {
            id,
            user_id,
            token: token.to_string(),
            created_at: now,
            expires_at,
        })
    }

    /// Get session by token
    pub async fn get_session_by_token(&self, token: &str) -> AppResult<Option<Session>> {
        let session = sqlx::query_as::<_, Session>(
            "SELECT id, user_id, token, created_at, expires_at FROM sessions WHERE token = ?"
        )
        .bind(token)
        .fetch_optional(&self.pool)
        .await?;

        Ok(session)
    }

    /// Delete session
    pub async fn delete_session(&self, token: &str) -> AppResult<()> {
        sqlx::query("DELETE FROM sessions WHERE token = ?")
            .bind(token)
            .execute(&self.pool)
            .await?;

        Ok(())
    }

    /// Delete expired sessions
    pub async fn delete_expired_sessions(&self) -> AppResult<u64> {
        let now = chrono::Utc::now().timestamp();

        let result = sqlx::query("DELETE FROM sessions WHERE expires_at < ?")
            .bind(now)
            .execute(&self.pool)
            .await?;

        Ok(result.rows_affected())
    }
}

// ==================== Data Models ====================

/// User model
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct User {
    pub id: i64,
    pub username: String,
    pub email: String,
    #[serde(skip_serializing)]
    pub password_hash: String,
    pub created_at: i64,
    pub updated_at: i64,
}

/// Create user request
#[derive(Debug, Deserialize)]
pub struct CreateUser {
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

/// Update user request
#[derive(Debug, Deserialize)]
pub struct UpdateUser {
    pub email: Option<String>,
    pub password_hash: Option<String>,
}

/// Setting model
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Setting {
    pub key: String,
    pub value: String,
    pub updated_at: i64,
}

/// Session model
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Session {
    pub id: i64,
    pub user_id: i64,
    pub token: String,
    pub created_at: i64,
    pub expires_at: i64,
}
