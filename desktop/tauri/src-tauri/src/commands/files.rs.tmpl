/*! File Operations Commands - File system interactions
 *
 * Author: {{AUTHOR}}
 */

use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use tokio::fs;

use crate::error::AppError;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileInfo {
    pub name: String,
    pub path: String,
    pub is_dir: bool,
    pub is_file: bool,
    pub size: u64,
    pub modified: Option<i64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadFileOptions {
    pub encoding: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WriteFileOptions {
    pub create_dir: bool,
    pub append: bool,
}

/// Read file contents as string
///
/// Reads the entire file into memory and returns as a string.
///
/// # Arguments
/// * `path` - Absolute or relative path to the file
///
/// # Security
/// Consider implementing path validation to prevent directory traversal attacks.
#[tauri::command]
pub async fn read_file(path: String) -> Result<String, AppError> {
    let path = validate_path(&path)?;

    let contents = fs::read_to_string(&path)
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to read file: {}", e)))?;

    Ok(contents)
}

/// Read file contents as bytes
///
/// Reads the entire file into memory and returns as a byte array.
///
/// # Arguments
/// * `path` - Absolute or relative path to the file
#[tauri::command]
pub async fn read_file_binary(path: String) -> Result<Vec<u8>, AppError> {
    let path = validate_path(&path)?;

    let contents = fs::read(&path)
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to read file: {}", e)))?;

    Ok(contents)
}

/// Write string contents to file
///
/// Creates or overwrites a file with the provided content.
///
/// # Arguments
/// * `path` - Absolute or relative path to the file
/// * `contents` - String content to write
/// * `options` - Write options (create directories, append mode)
#[tauri::command]
pub async fn write_file(
    path: String,
    contents: String,
    options: Option<WriteFileOptions>,
) -> Result<(), AppError> {
    let path = validate_path(&path)?;
    let opts = options.unwrap_or(WriteFileOptions {
        create_dir: true,
        append: false,
    });

    // Create parent directories if requested
    if opts.create_dir {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .await
                .map_err(|e| AppError::FileSystem(format!("Failed to create directories: {}", e)))?;
        }
    }

    // Write or append to file
    if opts.append {
        use tokio::io::AsyncWriteExt;
        let mut file = fs::OpenOptions::new()
            .append(true)
            .create(true)
            .open(&path)
            .await
            .map_err(|e| AppError::FileSystem(format!("Failed to open file: {}", e)))?;

        file.write_all(contents.as_bytes())
            .await
            .map_err(|e| AppError::FileSystem(format!("Failed to write file: {}", e)))?;
    } else {
        fs::write(&path, contents)
            .await
            .map_err(|e| AppError::FileSystem(format!("Failed to write file: {}", e)))?;
    }

    Ok(())
}

/// List directory contents
///
/// Returns information about all files and directories in the specified path.
///
/// # Arguments
/// * `path` - Absolute or relative path to the directory
#[tauri::command]
pub async fn list_directory(path: String) -> Result<Vec<FileInfo>, AppError> {
    let path = validate_path(&path)?;

    if !path.is_dir() {
        return Err(AppError::Validation("Path is not a directory".to_string()));
    }

    let mut entries = Vec::new();
    let mut read_dir = fs::read_dir(&path)
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to read directory: {}", e)))?;

    while let Some(entry) = read_dir
        .next_entry()
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to read entry: {}", e)))?
    {
        let metadata = entry
            .metadata()
            .await
            .map_err(|e| AppError::FileSystem(format!("Failed to get metadata: {}", e)))?;

        let modified = metadata
            .modified()
            .ok()
            .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
            .map(|d| d.as_secs() as i64);

        entries.push(FileInfo {
            name: entry.file_name().to_string_lossy().to_string(),
            path: entry.path().to_string_lossy().to_string(),
            is_dir: metadata.is_dir(),
            is_file: metadata.is_file(),
            size: metadata.len(),
            modified,
        });
    }

    // Sort by name
    entries.sort_by(|a, b| a.name.cmp(&b.name));

    Ok(entries)
}

/// Check if file or directory exists
///
/// Returns true if the path exists, false otherwise.
///
/// # Arguments
/// * `path` - Absolute or relative path to check
#[tauri::command]
pub async fn file_exists(path: String) -> Result<bool, AppError> {
    let path = PathBuf::from(&path);
    Ok(path.exists())
}

/// Get file metadata
///
/// Returns detailed information about a file or directory.
///
/// # Arguments
/// * `path` - Absolute or relative path to the file
#[tauri::command]
pub async fn get_file_info(path: String) -> Result<FileInfo, AppError> {
    let path = validate_path(&path)?;

    let metadata = fs::metadata(&path)
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to get file info: {}", e)))?;

    let modified = metadata
        .modified()
        .ok()
        .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
        .map(|d| d.as_secs() as i64);

    Ok(FileInfo {
        name: path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string(),
        path: path.to_string_lossy().to_string(),
        is_dir: metadata.is_dir(),
        is_file: metadata.is_file(),
        size: metadata.len(),
        modified,
    })
}

/// Delete file or empty directory
///
/// Removes a file or empty directory from the file system.
///
/// # Arguments
/// * `path` - Absolute or relative path to delete
///
/// # Security
/// Consider implementing additional checks or confirmations for delete operations.
#[tauri::command]
pub async fn delete_file(path: String) -> Result<(), AppError> {
    let path = validate_path(&path)?;

    let metadata = fs::metadata(&path)
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to get file info: {}", e)))?;

    if metadata.is_dir() {
        fs::remove_dir(&path)
            .await
            .map_err(|e| AppError::FileSystem(format!("Failed to delete directory: {}", e)))?;
    } else {
        fs::remove_file(&path)
            .await
            .map_err(|e| AppError::FileSystem(format!("Failed to delete file: {}", e)))?;
    }

    Ok(())
}

/// Create directory
///
/// Creates a new directory, creating parent directories as needed.
///
/// # Arguments
/// * `path` - Absolute or relative path for the new directory
#[tauri::command]
pub async fn create_directory(path: String) -> Result<(), AppError> {
    let path = validate_path(&path)?;

    fs::create_dir_all(&path)
        .await
        .map_err(|e| AppError::FileSystem(format!("Failed to create directory: {}", e)))?;

    Ok(())
}

// Helper functions

/// Validate and sanitize file paths
///
/// Prevents directory traversal attacks by validating path components.
fn validate_path(path_str: &str) -> Result<PathBuf, AppError> {
    let path = PathBuf::from(path_str);

    // Security: prevent directory traversal
    for component in path.components() {
        if let std::path::Component::ParentDir = component {
            return Err(AppError::Validation(
                "Path contains invalid components (..)".to_string(),
            ));
        }
    }

    Ok(path)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_write_and_read_file() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        let file_path_str = file_path.to_string_lossy().to_string();

        // Write file
        let result = write_file(
            file_path_str.clone(),
            "Hello, World!".to_string(),
            None,
        )
        .await;
        assert!(result.is_ok());

        // Read file
        let contents = read_file(file_path_str).await.unwrap();
        assert_eq!(contents, "Hello, World!");
    }

    #[tokio::test]
    async fn test_file_exists() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        let file_path_str = file_path.to_string_lossy().to_string();

        // File doesn't exist yet
        let exists = file_exists(file_path_str.clone()).await.unwrap();
        assert!(!exists);

        // Create file
        write_file(file_path_str.clone(), "test".to_string(), None)
            .await
            .unwrap();

        // Now it exists
        let exists = file_exists(file_path_str).await.unwrap();
        assert!(exists);
    }

    #[tokio::test]
    async fn test_list_directory() {
        let temp_dir = TempDir::new().unwrap();
        let dir_path = temp_dir.path().to_string_lossy().to_string();

        // Create some test files
        let file1 = temp_dir.path().join("file1.txt");
        let file2 = temp_dir.path().join("file2.txt");
        tokio::fs::write(&file1, "test1").await.unwrap();
        tokio::fs::write(&file2, "test2").await.unwrap();

        // List directory
        let entries = list_directory(dir_path).await.unwrap();
        assert_eq!(entries.len(), 2);
        assert!(entries.iter().any(|e| e.name == "file1.txt"));
        assert!(entries.iter().any(|e| e.name == "file2.txt"));
    }

    #[tokio::test]
    async fn test_validate_path_security() {
        let result = validate_path("../etc/passwd");
        assert!(result.is_err());

        let result = validate_path("../../sensitive");
        assert!(result.is_err());

        let result = validate_path("valid/path/file.txt");
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_create_directory() {
        let temp_dir = TempDir::new().unwrap();
        let new_dir = temp_dir.path().join("nested/deep/dir");
        let new_dir_str = new_dir.to_string_lossy().to_string();

        let result = create_directory(new_dir_str.clone()).await;
        assert!(result.is_ok());

        let exists = file_exists(new_dir_str).await.unwrap();
        assert!(exists);
    }
}
